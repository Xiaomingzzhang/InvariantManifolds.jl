var documenterSearchIndex = {"docs":
[{"location":"non_smooth_one/#One-Dimensional-Non-Smooth-Manifolds","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"","category":"section"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"Perhaps the most notable feature of this package is its ability to compute non-smooth manifolds. Currently, it supports the computation of non-smooth manifolds for two types of systems:","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"One-dimensional manifold computation for time-periodic non-smooth differential equations\nTwo-dimensional manifold computation for non-smooth autonomous systems","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"The manifolds in both cases are invariant manifolds of saddle points. The former requires taking time-periodic mappings, while the latter requires taking fixed-step time-T-mappings. The non-smooth factors in these two types of systems can be diverse, including piecewise smooth functions, collisions, and combinations thereof. Users don't need to solve these three types of non-smooth systems themselves, as we provide three encapsulated structures:","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"PiecewiseV\nBilliardV\nPiecewiseImpactV","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"We use the Callback functionality from OrdinaryDiffEq.jl to compute time mappings. The following three examples will demonstrate the methods for computing invariant manifolds of these three types of non-smooth systems.","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"warning: Warning\nThe computation of non-smooth manifolds heavily depends on the ODE solving algorithm and precision. When the solution fails or performs poorly, try changing the algorithm, increasing the ODE solving precision, or reducing the values of parameters ϵ, d, amax in NSOneDManifoldProblem.","category":"page"},{"location":"non_smooth_one/#Piecewise-Smooth-Systems","page":"One-Dimensional Non-Smooth Manifolds","title":"Piecewise Smooth Systems","text":"","category":"section"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"Consider a simple piecewise smooth system:","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"beginaligned\ndotx=y\ndoty=f(x) + epsilon sin(2pi t)\nendaligned","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"where","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"f(x) =\nbegincases\n-k_1 x textif  x  -d\nk_2 x  textif  -dxd\n-k_3 x textif  x  d\nendcases","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"k_1k_2k_3d0","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"are all positive constants. We will compute the invariant manifold of the time-periodic mapping. Note that when the periodic perturbation is small, the saddle point should be close to the origin.","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"First, let's load the required packages","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"using InvariantManifolds, LinearAlgebra, StaticArrays, OrdinaryDiffEq, CairoMakie","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"Next, define the piecewise smooth vector field:","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"f1(x, p, t) = SA[x[2], p[1]*x[1]+p[4]*sin(2pi * t)]\nf2(x, p, t) = SA[x[2], -p[2]*x[1]+p[4]*sin(2pi * t)]\nf3(x, p, t) = SA[x[2], -p[3]*x[1]+p[4]*sin(2pi * t)]\n\nhyper1(x, p, t) = x[1] - p[5]\nhyper2(x, p, t) = x[1] + p[5]\n\ndom1(x, p, t) = -p[5] < x[1] < p[5]\ndom2(x, p, t) = x[1] > p[5]\ndom3(x, p, t) = x[1] < -p[5]\n\nvectorfield = PiecewiseV((f1, f2, f3), (dom1, dom2, dom3), (hyper1, hyper2))","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"The parameters passed to the PiecewiseV structure are: vector fields, their domains, and the hyperplanes that divide these domains. For more details, refer to PiecewiseV.","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"Next, we'll encapsulate the key information for solving the time-periodic mapping in another structure NSSetUp:","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"setup = setmap(vectorfield, (0.0, 1.0), Tsit5(), abstol=1e-8)","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"The function setmap is used to encapsulate the time mapping computation information. Now we have defined everything needed to solve the time-periodic mapping.","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"Next, to generate the local manifold, we also need to locate the saddle point and its unstable eigenvector. Let's set the parameters:","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"para = [2, 5, 5, 0.6, 2]","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"Since the perturbation is small, the saddle-type periodic orbit should still be in dom1. Therefore, we can use findsaddle to calculate the position of the saddle point:","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"function df1(x, p, t)\n    SA[0 1; p[1] 0]\nend\ninitialguess = SA[0.0, 0.0]\nsaddle = findsaddle(f1, df1, (0.0,1.0), initialguess, para, abstol=1e-10)","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"Next, create the problem, generate the local manifold, and perform the extension","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"prob = NSOneDManifoldProblem(setup, para, ϵ = 1e-3)\nsegment = gen_segment(saddle)\nmanifold = growmanifold(prob, segment, 8)","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"Note that the data type of manifold.data is Vector{Vector{S}}, where S is an interpolation function. So we need to use the following function to plot the results:","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"using CairoMakie\nfunction manifold_plot(data)\n    fig = Figure()\n    axes = Axis(fig[1,1])\n    for k in eachindex(data)\n        for j in eachindex(data[k])\n            points=Point2f.(data[k][j].u)\n            lines!(axes, points)\n        end\n    end\n    fig\nend\nmanifold_plot(manifold.data)","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"Full codes without comments:","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"using InvariantManifolds, LinearAlgebra, StaticArrays, OrdinaryDiffEq, CairoMakie\nf1(x, p, t) = SA[x[2], p[1]*x[1]+p[4]*sin(2pi * t)]\nf2(x, p, t) = SA[x[2], -p[2]*x[1]+p[4]*sin(2pi * t)]\nf3(x, p, t) = SA[x[2], -p[3]*x[1]+p[4]*sin(2pi * t)]\nhyper1(x, p, t) = x[1] - p[5]\nhyper2(x, p, t) = x[1] + p[5]\ndom1(x, p, t) = -p[5] < x[1] < p[5]\ndom2(x, p, t) = x[1] > p[5]\ndom3(x, p, t) = x[1] < -p[5]\nvectorfield = PiecewiseV((f1, f2, f3), (dom1, dom2, dom3), (hyper1, hyper2))\nsetup = setmap(vectorfield, (0.0, 1.0), Tsit5(), abstol=1e-8)\npara = [2, 5, 5, 0.6, 2]\nfunction df1(x, p, t)\n    SA[0 1; p[1] 0]\nend\ninitialguess = SA[0.0, 0.0]\nsaddle = findsaddle(f1, df1, (0.0,1.0), initialguess, para, abstol=1e-10)\nprob = NSOneDManifoldProblem(setup, para, ϵ = 1e-3)\nsegment = gen_segment(saddle)\nmanifold = growmanifold(prob, segment, 8)\nusing CairoMakie\nfunction manifold_plot(data)\n    fig = Figure()\n    axes = Axis(fig[1,1])\n    for k in eachindex(data)\n        for j in eachindex(data[k])\n            points=Point2f.(data[k][j].u)\n            lines!(axes,points)\n        end\n    end\n    fig\nend\nmanifold_plot(manifold.data)","category":"page"},{"location":"non_smooth_one/#Impact-Systems","page":"One-Dimensional Non-Smooth Manifolds","title":"Impact Systems","text":"","category":"section"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"Consider the following forced inverted pendulum equation:","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"beginaligned\ndotx= y\ndoty= sin(x) - epsilon cos(2pi t)\nendaligned","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"Assume there are walls on both sides of the inverted pendulum: when x=xi or x=-xi, we have yrightarrow - ry. Similarly, we need to first construct the non-smooth vector field","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"f(x, p, t) = SA[x[2], sin(x[1])-p[1]*cos(2 * pi * t)]\n\nhyper1(x, p, t) = x[1] + p[2]\nhyper2(x, p, t) = x[1] - p[2]\n\nrule1(x, p, t) = SA[x[1], -p[3]*x[2]]\nrule2(x, p, t) = SA[x[1], -p[3]*x[2]]\n\nvectorfield = BilliardV(f, (hyper1, hyper2), (rule1, rule2))","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"Next, encapsulate the information for solving the time-periodic mapping:","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"setup = setmap(vectorfield, (0.0, 1.0), Vern9(), abstol=1e-10)","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"Find the saddle point:","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"function df(x, p, t)\n    SA[0 1; cos(x[1]) 0]\nend\npara = [0.2, pi / 4, 0.98]\ninitialguess = SA[0.0, 0.0]\nsaddle = findsaddle(f, df, (0.0,1.0), initialguess, para, abstol=1e-10)","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"Next, create the problem, generate the local manifold, and perform the extension","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"prob = NSOneDManifoldProblem(setup, para)\nsegment = gen_segment(saddle)\nmanifold = growmanifold(prob, segment, 11)","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"Finally, plot the results: ","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"manifold_plot(manifold.data)","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"Full codes without comments:","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"using InvariantManifolds, LinearAlgebra, StaticArrays, OrdinaryDiffEq, CairoMakie\nf(x, p, t) = SA[x[2], sin(x[1])-p[1]*cos(2 * pi * t)]\nhyper1(x, p, t) = x[1] + p[2]\nhyper2(x, p, t) = x[1] - p[2]\nrule1(x, p, t) = SA[x[1], -p[3]*x[2]]\nrule2(x, p, t) = SA[x[1], -p[3]*x[2]]\nvectorfield = BilliardV(f, (hyper1, hyper2), (rule1, rule2))\nsetup = setmap(vectorfield, (0.0, 1.0), Vern9(), abstol=1e-10)\nfunction df(x, p, t)\n    SA[0 1; cos(x[1]) 0]\nend\npara = [0.2, pi / 4, 0.98]\ninitialguess = SA[0.0, 0.0]\nsaddle = findsaddle(f, df, (0.0,1.0), initialguess, para, abstol=1e-10)\nprob = NSOneDManifoldProblem(setup, para)\nsegment = gen_segment(saddle)\nmanifold = growmanifold(prob, segment, 11)\nfunction manifold_plot(data)\n    fig = Figure()\n    axes = Axis(fig[1,1])\n    for k in eachindex(data)\n        for j in eachindex(data[k])\n            points=Point2f.(data[k][j].u)\n            lines!(axes,points)\n        end\n    end\n    fig\nend\nmanifold_plot(manifold.data)","category":"page"},{"location":"non_smooth_one/#Combined-Piecewise-Smooth-and-Impact-ODE-Systems","page":"One-Dimensional Non-Smooth Manifolds","title":"Combined Piecewise Smooth and Impact ODE Systems","text":"","category":"section"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"Now consider an ODE system with both piecewise smooth functions and impacts:","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"beginaligned\ndotx=y\ndoty=f(x) + epsilon sin(2pi t)\nendaligned","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"where","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"f(x) =\nbegincases\n-k_1 x textif  x  -d\nk_2 x  textif  -dxd\nendcases","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"k_1k_2d0","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"are all positive constants. When x=d, we have doty--rdoty. We will compute the invariant manifold of the time-periodic mapping. Note that when the periodic perturbation is small, the saddle point should be close to the origin. First, let's load the required packages","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"using InvariantManifolds, LinearAlgebra, StaticArrays, OrdinaryDiffEq, CairoMakie","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"Next, define the non-smooth vector field:","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"f1(x, p, t) = SA[x[2], p[1]*x[1]+p[3]*sin(2pi * t)]\nf2(x, p, t) = SA[x[2], -p[2]*x[1]+p[3]*sin(2pi * t)]\n\nhyper1(x, p, t) = x[1] - p[4]\nhyper2(x, p, t) = x[1] + p[4]\n\ndom1(x, p, t) = -p[4] < x[1]\ndom2(x, p, t) = x[1] < -p[4]\n\nimpact_rule(x, p, t) = SA[x[1], -p[5]*x[2]]\nid(x,p,t) = x\n\nvectorfield = PiecewiseImpactV((f1, f2), (dom1, dom2), (hyper1, hyper2), (impact_rule, id), [1])","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"The parameters passed to the PiecewiseImpactV structure are: vector fields, their domains, the hyperplanes that divide these domains, the rules that act on the hyperplanes, and a list of rules that have impact effects. For more details, refer to PiecewiseImpactV.","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"Next, we'll encapsulate the key information for solving the time-periodic mapping in another structure NSSetUp:","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"setup = setmap(vectorfield, (0.0, 1.0), Tsit5(), abstol=1e-8, reltol=1e-8)","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"The function setmap is used to encapsulate the time mapping computation information. Now we have defined everything needed to solve the time-periodic mapping.","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"Next, to generate the local manifold, we also need to locate the saddle point and its unstable eigenvector. Let's set the parameters:","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"para = [2, 5, 0.5, 2, 0.98]","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"Since the perturbation is small, the saddle-type periodic orbit should still be in dom1. Therefore, we can use findsaddle to calculate the position of the saddle point:","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"function df1(x, p, t)\n    SA[0 1; p[1] 0]\nend\ninitialguess = SA[0.0, 0.0]\nsaddle = findsaddle(f1, df1, (0.0, 1.0), initialguess, para, abstol=1e-10)","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"Next, create the problem, generate the local manifold, and perform the extension","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"prob = NSOneDManifoldProblem(setup, para)\nsegment = gen_segment(saddle)\nmanifold = growmanifold(prob, segment, 9)","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"Note that the data type of manifold.data is Vector{Vector{S}}, where S is an interpolation function. So we need to use the following function to plot the results:","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"using CairoMakie\nfunction manifold_plot(data)\n    fig = Figure()\n    axes = Axis(fig[1,1])\n    for k in eachindex(data)\n        for j in eachindex(data[k])\n            points=Point2f.(data[k][j].u)\n            lines!(axes,points)\n        end\n    end\n    fig\nend\nmanifold_plot(manifold.data)","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"Full codes without comments:","category":"page"},{"location":"non_smooth_one/","page":"One-Dimensional Non-Smooth Manifolds","title":"One-Dimensional Non-Smooth Manifolds","text":"using InvariantManifolds, LinearAlgebra, StaticArrays, OrdinaryDiffEq, CairoMakie\nf1(x, p, t) = SA[x[2], p[1]*x[1]+p[3]*sin(2pi * t)]\nf2(x, p, t) = SA[x[2], -p[2]*x[1]+p[3]*sin(2pi * t)]\nhyper1(x, p, t) = x[1] - p[4]\nhyper2(x, p, t) = x[1] + p[4]\ndom1(x, p, t) = -p[4] < x[1]\ndom2(x, p, t) = x[1] < -p[4]\nimpact_rule(x, p, t) = SA[x[1], -p[5]*x[2]]\nid(x,p,t) = x\nvectorfield = PiecewiseImpactV((f1, f2), (dom1, dom2), (hyper1, hyper2), (impact_rule, id), [1])\nsetup = setmap(vectorfield, (0.0, 1.0), Tsit5(), abstol=1e-8, reltol=1e-8)\npara = [2, 5, 0.5, 2, 0.98]\ninitialguess = SA[0.0, 0.0]\nfunction df1(x, p, t)\n    SA[0 1; p[1] 0]\nend\nsaddle = findsaddle(f1, df1, (0.0,1.0), initialguess, para, abstol=1e-10)\nsegment = gen_segment(saddle)\nprob = NSOneDManifoldProblem(setup, para)\nmanifold = growmanifold(prob, segment, 9)\nfunction manifold_plot(data)\n    fig = Figure()\n    axes = Axis(fig[1,1])\n    for k in eachindex(data)\n        for j in eachindex(data[k])\n            points=Point2f.(data[k][j].u)\n            lines!(axes,points)\n        end\n    end\n    fig\nend\nmanifold_plot(manifold.data)","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api/#InvariantManifolds.BilliardV","page":"API","title":"InvariantManifolds.BilliardV","text":"BilliardV\n\nA callable struct to represent a vector field with multiple hyper surfaces such that the flow jump when hits these hyper surfaces.\n\nFields\n\nf is the vector field, of type f(x,p,t), and its output is a SVector;\nhypers is tuple of hyper surfaces:(h1,h2,...), h1(x,p,t);\nrules is tuple of rules on hyper surfaces:(r1,r2,r3,...).\n\n\n\n\n\n","category":"type"},{"location":"api/#InvariantManifolds.FlawPoint","page":"API","title":"InvariantManifolds.FlawPoint","text":"FlawPoint{N,T}\n\nFlawPoint is a struct to record the points that don't satisfy the angle and distance request while the  program has reached the minimum arc length.\n\nFields\n\npoint flaw point in the process of continuation;\nα the angle recorded;\nd the distance recorded.\n\n\n\n\n\n","category":"type"},{"location":"api/#InvariantManifolds.NSOneDManifold","page":"API","title":"InvariantManifolds.NSOneDManifold","text":"NSOneDManifold{F,S,N,T}\n\nNSOneDManifold is a struct contains all the information of the non-smooth one-dimensional numerical manifold.\n\nFields\n\nprob the problem NSOneDManifoldProblem;\ndata the numerical data that should be Vector{Vector{Vector{S}}}, where S is the interpolation curve (we use DataInterpolation in this package);\nflawpoints the flaw points generated during continuation.\n\n\n\n\n\n","category":"type"},{"location":"api/#InvariantManifolds.NSOneDManifoldProblem","page":"API","title":"InvariantManifolds.NSOneDManifoldProblem","text":"NSOneDManifoldProblem{F,T}\n\nNSOneDManifoldProblem is a struct to contain the main information for continuing the non-smooth one-dimensional manifold of the time-T-map of a non-smooth ODE.\n\nFields\n\nf the struct NSSetUp;\npara the parameters of the nonlinear map;\namax the maximum angle between points when continuing the manifold;\nd the maximum distance between points when continuing the manifold;\nϵ the max value of the following expression: maxH(x_0T)H(x_1T) where H(xt) is the hypersurface the manifold cross, x_0 and x_1 are points before and after the cross, T is the end of the time-T-map (from 0 to T).\ndsmin the minimum arc length allowing; note that if in a continuation point, this value is achieved and the angle as well as the distance values are not achieved, then we will record this point as a FlawPoint.\n\nConvenient consturctors are NSOneDManifoldProblem(f) and NSOneDManifoldProblem(f,para)\n\n\n\n\n\n","category":"type"},{"location":"api/#InvariantManifolds.NSSetUp","page":"API","title":"InvariantManifolds.NSSetUp","text":"NSSetUp{T}\n\nNSSetUp is a struct to contain all the information needed in continuing the manifold of non-smooth ODE.\n\nFields\n\nf the Non-smooth vector field, like PiecewiseV;\ntimespan the time span of time-T-map;\ntimetmap the time-t-map of non-smooth ODE, which maps a NSState and parameters of ODE to a NSState.\n\n\n\n\n\n","category":"type"},{"location":"api/#InvariantManifolds.NSSolution","page":"API","title":"InvariantManifolds.NSSolution","text":"NSSolution{N,T<:Number}\n\nThe NSSolution is a struct to contain all information of the solution of a non-smooth ODE system.\n\nFields\n\nsol ODESolution solved by OrdinaryDiffEq;\nevent_t the times when events happen;\nevent_state the solution's state when events happen;\nevent_at is a vector that contains integers indicating which event happen.\n\n\n\n\n\n","category":"type"},{"location":"api/#InvariantManifolds.NSState","page":"API","title":"InvariantManifolds.NSState","text":"NSState{N,T<:Number} <: AbstractVector{T}\n\nThe struct NSState is to record the events data for a time-T-map.\n\nFields\n\nstate the final state of the time-T-map;\nevent_at is a integer vector that contains the history of the events happened.\n\nThe construction of NSState allows to interpolate vectors consisting of NSState. Currently, LinearInterpolation, CubicSpline, and QuadraticInterpolation in DataInterpolations.jl are supported.\n\n\n\n\n\n","category":"type"},{"location":"api/#InvariantManifolds.NSVTwoDManifold","page":"API","title":"InvariantManifolds.NSVTwoDManifold","text":"NSVTwoDManifold{F,S,N,T}\n\nNSVTwoDManifold is a struct contains all the information of the non-smooth two-dimensional numerical manifold of an autonomous vector field.\n\nFields\n\nprob the problem NSVTwoDManifoldProblem;\ndata the numerical data that should be Vector{Vector{S}}, where S is the interpolation curve (we use DataInterpolation in this package);\nflawpoints the flaw points generated during continuation.\n\n\n\n\n\n","category":"type"},{"location":"api/#InvariantManifolds.NSVTwoDManifoldProblem","page":"API","title":"InvariantManifolds.NSVTwoDManifoldProblem","text":"NSVTwoDManifoldProblem{F,T}\n\nNSVTwoDManifoldProblemVTwoDManifoldProblem is a struct to contain the main information for continuing the two-dimensional manifold of an autonomous vector field.\n\nFields\n\nf the NSSetUp of a nonsmooth vector field;\npara the parameters of the time flow map;\namax the maximum angle between points when continuing the manifold;\nd the maximum distance between points when continuing the manifold;\nϵ the max value of the following expression: maxH(x_0T)H(x_1T) where H(xt) is the hypersurface of the manifold cross, x_0 and x_1 are points before and after the cross, T is the end of the time-T-map (from 0 to T).\ndsmin the minimum arc length allowing; note that if in a continuation point, this value is achieved and the angle as well as the distance values are not achieved, then we will record this point as a FlawPoint.\n\nConvenient consturctors are NSVTwoDManifoldProblem(f) and NSVTwoDManifoldProblem(f,para)\n\n\n\n\n\n","category":"type"},{"location":"api/#InvariantManifolds.ODESolver","page":"API","title":"InvariantManifolds.ODESolver","text":"ODESolver{F1,F2,T}\n\nA wrapper struct for solving ordinary differential equations (ODEs).\n\nFields\n\nf: Vector field function of the ODE system in the form f(x,p,t)\ntimespan: Time interval for solving the ODE, of type Tuple{T,T}\nalg: The numerical algorithm used for solving the ODE\nabstol: Absolute tolerance for the numerical solver\n\n\n\n\n\n","category":"type"},{"location":"api/#InvariantManifolds.OneDManifold","page":"API","title":"InvariantManifolds.OneDManifold","text":"OneDManifold{F,S,N,T}\n\nOneDManifold is a struct contains all the information of the one-dimensional numerical manifold.\n\nFields\n\nprob the problem OneDManifoldProblem;\ndata the numerical data that should be Vector{Vector{S}}, where S is the interpolation curve (we use DataInterpolation in this package);\nflawpoints the flaw points generated during continuation.\n\n\n\n\n\n","category":"type"},{"location":"api/#InvariantManifolds.OneDManifoldProblem","page":"API","title":"InvariantManifolds.OneDManifoldProblem","text":"OneDManifoldProblem{F,T}\n\nOneDManifoldProblem is a struct to contain the main information for continuing the one-dimensional manifold of a nonlinear map.\n\nFields\n\nf the nonlinear map, which should has the form f(x,p) and return a SVector;\npara the parameters of the nonlinear map;\namax the maximum angle between points when continuing the manifold;\nd the maximum distance between points when continuing the manifold;\ndsmin the minimum arc length allowing; note that if in a continuation point, this value is achieved and the angle as well as the distance values are not achieved, then we will record this point as a FlawPoint.\n\nConvenient consturctors are OneDManifoldProblem(f) and OneDManifoldProblem(f,para)\n\n\n\n\n\n","category":"type"},{"location":"api/#InvariantManifolds.PiecewiseImpactV","page":"API","title":"InvariantManifolds.PiecewiseImpactV","text":"PiecewiseImpactV\n\nA callable struct to represent a vector field with both piecewise non-smoothness and impacts.\n\nfs is a tuple of smooth vector fields in different regions.\nregions is a tuple of the region functions: (r1,r2,...), where r1(x,p,t) should return a Bool value to indicate that x is in this region or not.\nhypers is a tuple of the hyper surfaces separating the regions.\nrules is a tuple of rules on hyper surfaces:(r1,r2,r3,...). Note that for hypersurfaces that only switch between two vector fields, we can set r1=id.\nidxs is a vector of integer to indicate hypersurfaces with impact effects.\nn is a integer to switch between vector fields. Default to be zero.\n\n\n\n\n\n","category":"type"},{"location":"api/#InvariantManifolds.PiecewiseV","page":"API","title":"InvariantManifolds.PiecewiseV","text":"PiecewiseV\n\nA callable struct to represent a piecewise smooth vector field. \n\nFields\n\nfs is a tuple of smooth vector fields in different regions.\nregions is a tuple of the region functions: (r1,r2,...), where r1(x,p,t) should return a Bool value to indicate that x is in this region or not.\nhypers is a tuple of the hyper surfaces separating the regions.\nn is a integer to switch between vector fields. Default to be zero.\n\nExample\n\nusing StaticArrays, InvariantManifolds\nf1(x,p,t)=SA[x[2],-2x[1]]\nf2(x,p,t)=SA[x[2],-x[1]]\ndom1(x,p,t)=x[1]>0\ndom2(x,p,t)=x[2]<0\nhyper(x,p,t)=x[1]\nPiecewiseV((f1,f2),(dom1,dom2),(hyper,))\n\nThe above codes generate a piecewise smooth vector field, which when x[1]>0 is f1, and when x[2]<0 is f2. The hyper surface separating these smooth vector fields is x[1]=0.\n\n\n\n\n\n","category":"type"},{"location":"api/#InvariantManifolds.Saddle","page":"API","title":"InvariantManifolds.Saddle","text":"Saddle{N,T,S}\n\nSaddle is a struct to contain the information of a saddle point needed in continuing the manifold of non-smooth ODE. For an ODE's saddle, this struct can be constructed by the function findsaddle.\n\nFields\n\nsaddle the location of the saddle point;\nunstable_directions the unstable directions;\nunstable_eigen_values eigenvalues of the linearized map in the saddle at the unstable eigenvectors.\n\n\n\n\n\n","category":"type"},{"location":"api/#InvariantManifolds.TwoDManifold","page":"API","title":"InvariantManifolds.TwoDManifold","text":"TwoDManifold{F,S,N,T}\n\nTwoDManifold is a struct contains all the information of the two-dimensional numerical manifold of a nonlinear map.\n\nFields\n\nprob the problem TwoDManifoldProblem;\ndata the numerical data that should be Vector{S}, where S is the interpolation curve (we use DataInterpolation in this package);\nflawpoints the flaw points generated during continuation.\n\n\n\n\n\n","category":"type"},{"location":"api/#InvariantManifolds.TwoDManifoldProblem","page":"API","title":"InvariantManifolds.TwoDManifoldProblem","text":"TwoDManifoldProblem{F,T}\n\nTwoDManifoldProblem is a struct to contain the main information for continuing the two-dimensional manifold of a nonlinear map.\n\nFields\n\nf the nonlinear map, which should has the form f(x,p) and return a SVector;\npara the parameters of the nonlinear map;\namax the maximum angle between points when continuing the manifold;\nd the maximum distance between points when continuing the manifold;\ndcircle the maximum distance between circles when continuing the manifold;\ndsmin the minimum arc length allowing; note that if in a continuation point, this value is achieved and the angle as well as the distance values are not achieved, then we will record this point as a FlawPoint.\n\nConvenient consturctors are TwoDManifoldProblem(f) and TwoDManifoldProblem(f,para)\n\n\n\n\n\n","category":"type"},{"location":"api/#InvariantManifolds.VTwoDManifold","page":"API","title":"InvariantManifolds.VTwoDManifold","text":"VTwoDManifold{F,S,N,T}\n\nVTwoDManifold is a struct contains all the information of the two-dimensional numerical manifold of an autonomous vector field.\n\nFields\n\nprob the problem VTwoDManifoldProblem;\ndata the numerical data that should be Vector{S}, where S is the interpolation curve (we use DataInterpolation in this package);\nflawpoints the flaw points generated during continuation.\n\n\n\n\n\n","category":"type"},{"location":"api/#InvariantManifolds.VTwoDManifoldProblem","page":"API","title":"InvariantManifolds.VTwoDManifoldProblem","text":"VTwoDManifoldProblem{F,T}\n\nVTwoDManifoldProblem is a struct to contain the main information for continuing the two-dimensional manifold of an autonomous vector field.\n\nFields\n\nf the time flow map of the vector field, which should has the form f(x,p) and return a SVector; note that the vector field should be regularized, e.g., dotx=v(x) should be rewritten as dotx=v(x)sqrt1+v(x);\npara the parameters of the time flow map;\namax the maximum angle between points when continuing the manifold;\nd the maximum distance between points when continuing the manifold;\ndsmin the minimum arc length allowing; note that if in a continuation point, this value is achieved and the angle as well as the distance values are not achieved, then we will record this point as a FlawPoint.\n\nConvenient consturctors are VTwoDManifoldProblem(f) and VTwoDManifoldProblem(f,para)\n\n\n\n\n\n","category":"type"},{"location":"api/#InvariantManifolds.addcircles!-NTuple{8, Any}","page":"API","title":"InvariantManifolds.addcircles!","text":"InvariantManifolds.addcircles!(f, para, d, circles, dsmin, αmax, dcircle, flawpoints; interp=LinearInterpolation)\n\nAdds and refines circles in the two-dimensional manifold computation by iterating the map and ensuring proper point distribution.\n\nArguments\n\nf: The nonlinear map function\npara: Vector of parameters for the map\nd: Maximum allowed distance between points in a circle\ncircles: Vector of interpolated curves representing the current circles\ndsmin: Minimum allowed arc length between points\nαmax: Maximum allowed angle between consecutive points\ndcircle: Maximum allowed distance between consecutive circles\nflawpoints: Vector to store problematic points during computation\ninterp: Interpolation method (default: QuadraticInterpolation)\n\nReturns\n\nA vector of new interpolated curves representing the refined circles after one iteration of the map.\n\nDetails\n\nThe function performs two main steps:\n\nIterates each circle forward under the map and refines point distribution within each circle\nAdds intermediate circles where the distance between consecutive circles exceeds dcircle\n\nPoints are added to maintain proper spacing and curvature constraints specified by d and αmax.\n\n\n\n\n\n","category":"method"},{"location":"api/#InvariantManifolds.addpoints!-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Any, Any, Array{StaticArraysCore.SVector{N, T}, 1}, Vector{T}, Any, Any, Any}} where {N, T}","page":"API","title":"InvariantManifolds.addpoints!","text":"InvariantManifolds.addpoints!(f, p, d, oldcurve, newu, olds, dsmin, αmax, flawpoints)\n\nAdd points to ensure proper spacing and curvature along a one-dimensional manifold curve.\n\nArguments\n\nf: The nonlinear map function\np: Parameters for the nonlinear map\nd: Maximum allowed distance between consecutive points\noldcurve: Previous curve interpolation\nnewu::Vector{SVector{N,T}}: New points to be processed\nolds::Vector{T}: Parameter values of the points\ndsmin: Minimum allowed arc length between points\nαmax: Maximum allowed angle between consecutive segments\nflawpoints: Vector to store problematic points that don't meet criteria\n\nDetails\n\nThe function iteratively processes points, adding new ones when:\n\nThe distance between consecutive points exceeds d\nThe angle between consecutive segments exceeds αmax\nThe arc length is greater than dsmin\n\nIf a point fails these criteria and the minimum arc length is reached, it's recorded as a flaw point.\n\nReturns\n\nVector of parameter values for the new points\n\n\n\n\n\n","category":"method"},{"location":"api/#InvariantManifolds.findsaddle-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Any, StaticArraysCore.SVector{N, T}, Any}} where {N, T}","page":"API","title":"InvariantManifolds.findsaddle","text":"findsaddle(v, dv, timespan, x, p)\n\nfindsaddle is a function to find the saddle of the time-T-map of smooth ODE systems, by using the Newton's method.\n\nParameters\n\nv the vector field, which should be the form f(x,p,t) and return a SVector;\ndv the Jacobi matrix function of v, which should should be the form dv(x,p,t) and return a SMatrix;\ntimespan the time span of the time-T-map;\nx the initial point to iterate.\n\nKeyword arguments\n\nn maximum iterate times, default to be 100;\nabstol absolute tolerance for the fixed point, default to be 1e-8;\nalg the algorithm used to solve the ODE, default to be Vern9().\n\nWe also provide the finite difference method to find the saddle of the time-T-map of nonsmooth ODE systems:\n\nParameters\n\nsetup the NSSetUp of the nonsmooth ODE system;\nx the initial point to iterate, of type SVector{N,T}.\np the parameters of the nonsmooth ODE system.\n\nKeyword arguments\n\nn maximum iterate times, default to be 100;\nabstol absolute tolerance for the fixed point, default to be 1e-8;\n\n\n\n\n\n","category":"method"},{"location":"api/#InvariantManifolds.gen_disk-Union{Tuple{Saddle{N, T, S}}, Tuple{S}, Tuple{T}, Tuple{N}} where {N, T, S}","page":"API","title":"InvariantManifolds.gen_disk","text":"gen_disk(p, times)\n\ngen_disk is a function to generate circles around the saddle, which represented as the local manifold.\n\nParameters\n\np the struct Saddle which should contains two unstable directions; the complex eigenvalues and eigenvectors are allowed.\n\nKeyword arguments\n\ntimes the iteration time, default to be 1; for the computation of invariant manifolds of nonlinear map, this parameter is needed to adjust the torsion in different directions in the process of continuation.\nn the number of point in each circle, default to be 150;\nd the max distance between points in a single circle, default to be 0.0002;\nr the size of the disk, default to be 0.05;\ncircles the number of the circles, default to be 10.\n\n\n\n\n\n","category":"method"},{"location":"api/#InvariantManifolds.gen_segment-Union{Tuple{T}, Tuple{N}, Tuple{StaticArraysCore.SVector{N, T}, Any}} where {N, T}","page":"API","title":"InvariantManifolds.gen_segment","text":"gen_segment(saddle, direction)\n\nGenerating n points at saddle in the direction, with length d, with default n=50 and d=0.01. Another Convenient consturctor is gen_segment(p::Saddle).\n\n\n\n\n\n","category":"method"},{"location":"api/#InvariantManifolds.grow!-Tuple{InvariantManifolds.OneDManifold}","page":"API","title":"InvariantManifolds.grow!","text":"grow!(manifold)\n\nOne time iteration to grow the manifold.\n\nParameters\n\nmanifold the manifold struct.\n\nKeyword argument\n\ninterp the interpolation method used, default to be QuadraticInterpolation.\n\n\n\n\n\n","category":"method"},{"location":"api/#InvariantManifolds.growmanifold-Tuple{OneDManifoldProblem, Any, Any}","page":"API","title":"InvariantManifolds.growmanifold","text":"growmanifold(prob, points, N)\n\nThis is the mani function to continuate the numerical manifolds. Its output is a manifold struct.\n\nParameters\n\nprob the problem such as OneDManifoldProblem.\npoints the points in the local manifold. For one dimensional manifolds, these points should be a Vector{SVector} and the start point should be the saddle. For two dimensional manifolds, these points should be a Vector{Vector{S}} and its first element should like [saddle, saddle, saddle]. Note that in the both cases, the functions gen_segment and gen_disk can generate these points easily.\nN the number of iterations.\n\nKeyword argument\n\ninterp the interpolation method used, default to be QuadraticInterpolation.\n\n\n\n\n\n","category":"method"},{"location":"api/#InvariantManifolds.initialize-Union{Tuple{T}, Tuple{N}, Tuple{OneDManifoldProblem, Array{StaticArraysCore.SVector{N, T}, 1}}} where {N, T}","page":"API","title":"InvariantManifolds.initialize","text":"initialize(prob, points)\n\nThis is a function to initialize the continuation process. Its output is a manifold struct.\n\nParameters\n\nprob the problem such as OneDManifoldProblem.\npoints the points in the local manifold. For one dimensional manifolds, these points should be a Vector{SVector} and the start point should be the saddle. For two dimensional manifolds, these points should be a Vector{Vector{S}} and its first element should like [saddle, saddle, saddle]. Note that in the both cases, the functions gen_segment and gen_disk can generate these points easily.\n\nKeyword argument\n\ninterp the interpolation method used, default to be QuadraticInterpolation.\n\n\n\n\n\n","category":"method"},{"location":"api/#InvariantManifolds.iscontact-Union{Tuple{S}, Tuple{T}, Tuple{N}, Tuple{Any, Saddle{N, T, S}, Any}} where {N, T, S}","page":"API","title":"InvariantManifolds.iscontact","text":"iscontact(setup, saddle, para)\n\nCheck if the saddle point of the time-T-map has contacts with the hypersurfaces.\n\nParameters\n\nsetup a NSSetUp.\nsaddle a Saddle or a SVector.\npara the parameter of the vector field.\n\nReturns\n\ntrue if the saddle point has contact with the hypersurfaces.\nfalse if the saddle point has no contact with the hypersurfaces.\n\n\n\n\n\n","category":"method"},{"location":"api/#InvariantManifolds.kd_distence-Union{Tuple{T}, Tuple{N}, Tuple{StaticArraysCore.SVector{N, T}, Array{StaticArraysCore.SVector{N, T}, 1}}} where {N, T}","page":"API","title":"InvariantManifolds.kd_distence","text":"InvariantManifolds.kd_distence\n\nThe function to measure the distance between two circles by using the package NearestNeighbors.jl.\n\n\n\n\n\n","category":"method"},{"location":"api/#InvariantManifolds.ns_addpoints!-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Any, Any, Any, Array{NSState{N, T}, 1}, Vector{T}, Vararg{Any, 5}}} where {N, T}","page":"API","title":"InvariantManifolds.ns_addpoints!","text":"InvariantManifolds.ns_addpoints!(tmap, p, d, dsmin, oldcurve, newu, olds, αmax, tend, hypers, ϵ, flawpoints) -> Vector{T}\n\nAdd points to ensure proper spacing and accuracy when computing the non-smooth one-dimensional manifold.\n\nArguments\n\ntmap: Time map function that evolves states forward\np: Vector of parameters\nd: Maximum allowed distance between consecutive points\ndsmin: Minimum allowed arc length between points\noldcurve: Previous curve data used for interpolation\nnewu: Vector of new states to be processed\nolds: Vector of arc length parameters\nαmax: Maximum allowed angle between consecutive segments\ntend: End time of the time map\nhypers: Vector of hypersurface functions\nϵ: Maximum allowed error in hypersurface intersection\nflawpoints: Vector to store problematic points encountered\n\nReturns\n\nVector of arc length parameters for the processed points\n\nDetails\n\nThe function adaptively adds points to maintain:\n\nMaximum distance d between consecutive points\nMaximum angle αmax between segments\nAccuracy ϵ at hypersurface intersections\n\nIf constraints cannot be satisfied within dsmin, points are marked as flaws.\n\n\n\n\n\n","category":"method"},{"location":"api/#InvariantManifolds.ns_solver-Tuple{PiecewiseV, Vararg{Any, 4}}","page":"API","title":"InvariantManifolds.ns_solver","text":"ns_solver(v::T, para, timespan, alg, N, T)\n\nThe function ns_solver is similar to timetmap. The output of this function is a function which maps a SVector to a NSSolution. This NSSolution contain all data of an non-smooth ODE solution.\n\nParameters\n\nv vector fields like PiecewiseV or BilliardV.\npara the parameter of the vector field.\ntimespan the time span of the time-T-map.\nalg algorithm in OrdinaryDiffEq to solve ODE.\nN the dimension of the vector field.\nT number type used in computation.\n\nTo ensure type stable, the numbers in para and timespan should be type of T. The last two parameters have to be specified, since we need to store the event data.\n\nKeyword arguments\n\nrepeat_nudge=1//100 this is used to set the next testing point after a previously found zero.\n\nFor vector fields PiecewiseV and PiecewiseImpactV, we have two special keyword arguments:\n\ncross_time= 0.01 when the solution sol hits the hypersurface at time t, we need to know which domain it enters. We choose the state sol(t+cross_time) to determine which domain it enters.\nregion_detect=_region_detect the region detect function to determine which domain the state in.\n\nYou can also pass the keywords of solve of OrdinaryDiffEq to this function,  except the callback and saving related keywords.\n\n\n\n\n\n","category":"method"},{"location":"api/#InvariantManifolds.setmap-Union{Tuple{T}, Tuple{PiecewiseV, Tuple{T, T}, Any}} where T","page":"API","title":"InvariantManifolds.setmap","text":"setmap(v, timespan::Tuple{T,T}, alg) where {T}\n\nThe function setmap is to get a NSSetUp.\n\nParameters\n\nv a nonsmooth vector field like PiecewiseV or BilliardV.\ntimespan the time span of the time-T-map.\nalg algorithm in OrdinaryDiffEq to solve ODE.\n\nTo ensure type stable, the numbers in timespan should be type of T.\n\nKeyword arguments\n\nrepeat_nudge=1//100 this is used to set the next testing point after a previously found zero.\n\nFor vector fields PiecewiseV and PiecewiseImpactV, we have two special keyword arguments:\n\ncross_time= 0.01 when the solution sol hits the hypersurface at time t, we need to know which domain it enters. We choose the state sol(t+cross_time) to determine which domain it enters.\nregion_detect=_region_detect the region detect function to determine which domain the state in.\n\nYou can also pass the keywords of solve of OrdinaryDiffEq to this function,  except the callback and saving related keywords.\n\n\n\n\n\n","category":"method"},{"location":"non_smooth_two/#Two-dimensional-Non-smooth-Manifold","page":"Two-dimensional Non-Smooth Manifolds","title":"Two-dimensional Non-smooth Manifold","text":"","category":"section"},{"location":"non_smooth_two/","page":"Two-dimensional Non-Smooth Manifolds","title":"Two-dimensional Non-Smooth Manifolds","text":"Next, we will continue using the Lorenz system as an example, but this time we will introduce an artificial non-smooth factor into this system. First, let's load the required packages:","category":"page"},{"location":"non_smooth_two/","page":"Two-dimensional Non-Smooth Manifolds","title":"Two-dimensional Non-Smooth Manifolds","text":"using InvariantManifolds, LinearAlgebra, StaticArrays, OrdinaryDiffEq, CairoMakie, DataInterpolations","category":"page"},{"location":"non_smooth_two/","page":"Two-dimensional Non-Smooth Manifolds","title":"Two-dimensional Non-Smooth Manifolds","text":"Next, define a vector field that normalizes when far from the origin:","category":"page"},{"location":"non_smooth_two/","page":"Two-dimensional Non-Smooth Manifolds","title":"Two-dimensional Non-Smooth Manifolds","text":"function lorenz(x, p, t)\n    σ, ρ, β = p\n    v = SA[σ*(x[2]-x[1]),\n        ρ*x[1]-x[2]-x[1]*x[3],\n        x[1]*x[2]-β*x[3]\n    ]\n    -v / sqrt(0.1 + norm(v)^2)\nend","category":"page"},{"location":"non_smooth_two/","page":"Two-dimensional Non-Smooth Manifolds","title":"Two-dimensional Non-Smooth Manifolds","text":"Unlike the previous example, we will introduce the following non-smooth factor: when z=xi, (xyz)rightarrow(x-yz). Therefore, we need to define a vector field with a collision factor:","category":"page"},{"location":"non_smooth_two/","page":"Two-dimensional Non-Smooth Manifolds","title":"Two-dimensional Non-Smooth Manifolds","text":"hyper(x,p,t) = x[3]-p[4]\nrule(x,p,t) = SA[x[1], -x[2], x[3]]\nvectorfield =BilliardV(lorenz, (hyper,),(rule,))","category":"page"},{"location":"non_smooth_two/","page":"Two-dimensional Non-Smooth Manifolds","title":"Two-dimensional Non-Smooth Manifolds","text":"Then, as in the previous example, we need to encapsulate the specific information for solving this differential equation into NSSetUp, which requires using the setmap function:","category":"page"},{"location":"non_smooth_two/","page":"Two-dimensional Non-Smooth Manifolds","title":"Two-dimensional Non-Smooth Manifolds","text":"setup = setmap(vectorfield, (0.0, 1.0), Tsit5(), abstol=1e-8)","category":"page"},{"location":"non_smooth_two/","page":"Two-dimensional Non-Smooth Manifolds","title":"Two-dimensional Non-Smooth Manifolds","text":"Next, we need to generate a local manifold:","category":"page"},{"location":"non_smooth_two/","page":"Two-dimensional Non-Smooth Manifolds","title":"Two-dimensional Non-Smooth Manifolds","text":"para = [10.0, 28.0, 8/3, 10.0]\nfunction eigenv(p)\n    σ, ρ, β = p\n    [SA[0.0, 0.0, 1.0], SA[-(-1 + σ + sqrt(1 - 2 * σ + 4 * ρ * σ + σ^2))/(2*ρ), 1, 0]]\nend\nsaddle = Saddle(SA[0, 0, 0.0], eigenv(para), [1.0, 1.0])\ndisk = gen_disk(saddle, r=1.0, d=0.1)","category":"page"},{"location":"non_smooth_two/","page":"Two-dimensional Non-Smooth Manifolds","title":"Two-dimensional Non-Smooth Manifolds","text":"Then create the problem:","category":"page"},{"location":"non_smooth_two/","page":"Two-dimensional Non-Smooth Manifolds","title":"Two-dimensional Non-Smooth Manifolds","text":"prob = NSVTwoDManifoldProblem(setup, para, amax=0.5, d=0.5, ϵ=0.2, dsmin=1e-3)","category":"page"},{"location":"non_smooth_two/","page":"Two-dimensional Non-Smooth Manifolds","title":"Two-dimensional Non-Smooth Manifolds","text":"Finally, calculate the manifold and plot the image:","category":"page"},{"location":"non_smooth_two/","page":"Two-dimensional Non-Smooth Manifolds","title":"Two-dimensional Non-Smooth Manifolds","text":"manifold = growmanifold(prob, disk, 90, interp=LinearInterpolation)\nfunction manifold_plot(annulus)\n    fig = Figure()\n    axes = LScene(fig[1, 1], show_axis=false, scenekw=(backgroundcolor=:white, clear=true))\n    second(x) = x[2]\n    for i in eachindex(annulus)\n        for j in eachindex(annulus[i])\n            points = Point3f.(annulus[i][j].u)\n            lines!(axes, points, fxaa=true)\n        end\n    end\n    fig\nend\nmanifold_plot(manifold.data)","category":"page"},{"location":"non_smooth_two/","page":"Two-dimensional Non-Smooth Manifolds","title":"Two-dimensional Non-Smooth Manifolds","text":"Full codes without comments:","category":"page"},{"location":"non_smooth_two/","page":"Two-dimensional Non-Smooth Manifolds","title":"Two-dimensional Non-Smooth Manifolds","text":"using InvariantManifolds, LinearAlgebra, StaticArrays, OrdinaryDiffEq, CairoMakie, DataInterpolations\nfunction lorenz(x, p, t)\n    σ, ρ, β = p\n    v = SA[σ*(x[2]-x[1]),\n        ρ*x[1]-x[2]-x[1]*x[3],\n        x[1]*x[2]-β*x[3]\n    ]\n    -v / sqrt(0.1 + norm(v)^2)\nend\nhyper(x,p,t) = x[3]-p[4]\nrule(x,p,t) = SA[x[1], -x[2], x[3]]\nvectorfield =BilliardV(lorenz, (hyper,),(rule,))\nsetup = setmap(vectorfield, (0.0, 1.0), Tsit5(), abstol=1e-8)\npara = [10.0, 28.0, 8/3, 10.0]\nfunction eigenv(p)\n    σ, ρ, β = p\n    [SA[0.0, 0.0, 1.0], SA[-(-1 + σ + sqrt(1 - 2 * σ + 4 * ρ * σ + σ^2))/(2*ρ), 1, 0]]\nend\nsaddle = Saddle(SA[0, 0, 0.0], eigenv(para), [1.0, 1.0])\ndisk = gen_disk(saddle, r=1.0, d=0.1)\nprob = NSVTwoDManifoldProblem(setup, para, amax=0.5, d=0.5, ϵ=0.2, dsmin=1e-3)\nmanifold = growmanifold(prob, disk, 90, interp=LinearInterpolation)\nfunction manifold_plot(annulus)\n    fig = Figure()\n    axes = LScene(fig[1, 1], show_axis=false, scenekw=(backgroundcolor=:white, clear=true))\n    second(x) = x[2]\n    for i in eachindex(annulus)\n        for j in eachindex(annulus[i])\n            points = Point3f.(annulus[i][j].u)\n            lines!(axes, points, fxaa=true)\n        end\n    end\n    fig\nend\nmanifold_plot(manifold.data)","category":"page"},{"location":"#InvariantManifolds.jl","page":"Home","title":"InvariantManifolds.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package aims to provide a convenient tool for numerically investigating low-dimensional invariant manifolds. We offer no guarantees regarding numerical stability or reliability.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Main idea:","category":"page"},{"location":"","page":"Home","title":"Home","text":"The core concept of this package is straightforward. By utilizing the local manifolds of saddle points, we progressively extend these manifolds. We maintain points in close proximity (controlled by distance and curvature) to ensure the accuracy of the numerical manifolds.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In this package, the two-dimensional algorithm for smooth mappings is built upon the one-dimensional algorithm. Numerical manifolds are represented as a collection of sufficiently close points, forming circles.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The most compelling aspect of this package lies in its ability to reliably compute non-smooth invariant manifolds. Please refer to the examples for further details.","category":"page"},{"location":"smooth_one/#Getting-Started:-One-Dimensional-Smooth-Manifolds","page":"Getting Started: One-Dimensional Smooth Manifolds","title":"Getting Started: One-Dimensional Smooth Manifolds","text":"","category":"section"},{"location":"smooth_one/#Nonlinear-Mapping","page":"Getting Started: One-Dimensional Smooth Manifolds","title":"Nonlinear Mapping","text":"","category":"section"},{"location":"smooth_one/","page":"Getting Started: One-Dimensional Smooth Manifolds","title":"Getting Started: One-Dimensional Smooth Manifolds","text":"Consider the following Henon map:","category":"page"},{"location":"smooth_one/","page":"Getting Started: One-Dimensional Smooth Manifolds","title":"Getting Started: One-Dimensional Smooth Manifolds","text":"beginaligned\nx=1-alpha x^2+y\ny=beta x\nendaligned","category":"page"},{"location":"smooth_one/","page":"Getting Started: One-Dimensional Smooth Manifolds","title":"Getting Started: One-Dimensional Smooth Manifolds","text":"where alphabeta are parameters. This mapping has fixed points:","category":"page"},{"location":"smooth_one/","page":"Getting Started: One-Dimensional Smooth Manifolds","title":"Getting Started: One-Dimensional Smooth Manifolds","text":"beginaligned\n(x_1y_1)=(frac-sqrt4 alpha +beta ^2-2 beta +1+beta -12 alpha frac12 left(fracbeta ^2alpha -fracbeta  sqrt4 alpha +beta ^2-2 beta +1alpha -fracbeta alpha right))\n(x_2y_2)=(fracsqrt4 alpha +beta ^2-2 beta +1+beta -12 alpha frac12 left(fracbeta ^2alpha +fracbeta  sqrt4 alpha +beta ^2-2 beta +1alpha -fracbeta alpha right))\nendaligned","category":"page"},{"location":"smooth_one/","page":"Getting Started: One-Dimensional Smooth Manifolds","title":"Getting Started: One-Dimensional Smooth Manifolds","text":"Let's calculate the eigenvalues of these two fixed points under the classical parameters alpha=14beta=03:","category":"page"},{"location":"smooth_one/","page":"Getting Started: One-Dimensional Smooth Manifolds","title":"Getting Started: One-Dimensional Smooth Manifolds","text":"using StaticArrays, LinearAlgebra\nfunction fixedpoints(p)\n    a , b = p\n    x1 = (-sqrt(4 * a + b^2 - 2 * b + 1) + b - 1) / (2 * a)\n    y1 = (1 / 2) * (b^2 / a - b * sqrt(4 * a + b^2 - 2 * b + 1) / a - b / a)\n    x2 = (sqrt(4 * a + b^2 - 2 * b + 1) + b - 1) / (2 * a)\n    y2 = (1 / 2) * (b^2 / a + b * sqrt(4 * a + b^2 - 2 * b + 1) / a - b / a)\n    return SA[x1, y1], SA[x2, y2]\nend\n\nfunction jacobian(x, p)\n    a, b = p\n    J = @SMatrix [-2 * a * x[1] 1.0; b 0.0]\n    return J\nend","category":"page"},{"location":"smooth_one/","page":"Getting Started: One-Dimensional Smooth Manifolds","title":"Getting Started: One-Dimensional Smooth Manifolds","text":"eigen(jacobian(fixedpoints([1.4, 0.3])[1], [1.4, 0.3]))","category":"page"},{"location":"smooth_one/","page":"Getting Started: One-Dimensional Smooth Manifolds","title":"Getting Started: One-Dimensional Smooth Manifolds","text":"eigen(jacobian(fixedpoints([1.4, 0.3])[2], [1.4, 0.3]))","category":"page"},{"location":"smooth_one/","page":"Getting Started: One-Dimensional Smooth Manifolds","title":"Getting Started: One-Dimensional Smooth Manifolds","text":"As we can see, under the classical parameters, both fixed points are unstable. Next, we'll use the InvariantManifolds.jl package to compute one branch of the unstable manifold of the second fixed point.","category":"page"},{"location":"smooth_one/","page":"Getting Started: One-Dimensional Smooth Manifolds","title":"Getting Started: One-Dimensional Smooth Manifolds","text":"The InvariantManifolds.jl package has an interface similar to many Julia packages. First, we need to load the package in Julia and define the Henon map:","category":"page"},{"location":"smooth_one/","page":"Getting Started: One-Dimensional Smooth Manifolds","title":"Getting Started: One-Dimensional Smooth Manifolds","text":"using InvariantManifolds\nfunction henonmap(x, p)\n    y1 = 1 - p[1] * x[1]^2 + x[2]\n    y2 = p[2] * x[1]\n    SA[y1, y2]\nend","category":"page"},{"location":"smooth_one/","page":"Getting Started: One-Dimensional Smooth Manifolds","title":"Getting Started: One-Dimensional Smooth Manifolds","text":"Since the unstable eigenvalue at the saddle point is:","category":"page"},{"location":"smooth_one/","page":"Getting Started: One-Dimensional Smooth Manifolds","title":"Getting Started: One-Dimensional Smooth Manifolds","text":"eigen(jacobian(fixedpoints([1.4, 0.3])[2], [1.4, 0.3])).values[1]","category":"page"},{"location":"smooth_one/","page":"Getting Started: One-Dimensional Smooth Manifolds","title":"Getting Started: One-Dimensional Smooth Manifolds","text":"We need to iterate this mapping twice to ensure the manifold doesn't reverse during extension:","category":"page"},{"location":"smooth_one/","page":"Getting Started: One-Dimensional Smooth Manifolds","title":"Getting Started: One-Dimensional Smooth Manifolds","text":"henonmap2(x, p)=henonmap(henonmap(x, p), p)","category":"page"},{"location":"smooth_one/","page":"Getting Started: One-Dimensional Smooth Manifolds","title":"Getting Started: One-Dimensional Smooth Manifolds","text":"Now let's define a problem for computing a one-dimensional manifold of the smooth mapping:","category":"page"},{"location":"smooth_one/","page":"Getting Started: One-Dimensional Smooth Manifolds","title":"Getting Started: One-Dimensional Smooth Manifolds","text":"para = [1.4, 0.3]\nprob = OneDManifoldProblem(henonmap2, para)","category":"page"},{"location":"smooth_one/","page":"Getting Started: One-Dimensional Smooth Manifolds","title":"Getting Started: One-Dimensional Smooth Manifolds","text":"To compute the manifold, we need a small local manifold segment starting at the saddle point. Usually, an unstable eigenvector starting at the saddle point with a very small length will suffice. InvariantManifolds.jl provides a function gen_segment to generate such a local manifold:","category":"page"},{"location":"smooth_one/","page":"Getting Started: One-Dimensional Smooth Manifolds","title":"Getting Started: One-Dimensional Smooth Manifolds","text":"saddle = fixedpoints(para)[2]\nunstable_direction = eigen(jacobian(fixedpoints([1.4, 0.3])[2], [1.4, 0.3])).vectors[:,1]\nsegment = gen_segment(saddle, unstable_direction)","category":"page"},{"location":"smooth_one/","page":"Getting Started: One-Dimensional Smooth Manifolds","title":"Getting Started: One-Dimensional Smooth Manifolds","text":"Under default keyword arguments, this function will generate a local manifold starting at the saddle point, with a length of 150 units and a step size of 0.01. Now let's use this local manifold to compute the smooth manifold:","category":"page"},{"location":"smooth_one/","page":"Getting Started: One-Dimensional Smooth Manifolds","title":"Getting Started: One-Dimensional Smooth Manifolds","text":"manifold = growmanifold(prob, segment, 8)","category":"page"},{"location":"smooth_one/","page":"Getting Started: One-Dimensional Smooth Manifolds","title":"Getting Started: One-Dimensional Smooth Manifolds","text":"This package doesn't provide plotting functionality. However, since the computation results are stored in manifold.data, and manifold.data is actually a vector whose elements are interpolation functions from the DataInterpolations.jl package:","category":"page"},{"location":"smooth_one/","page":"Getting Started: One-Dimensional Smooth Manifolds","title":"Getting Started: One-Dimensional Smooth Manifolds","text":"manifold.data","category":"page"},{"location":"smooth_one/","page":"Getting Started: One-Dimensional Smooth Manifolds","title":"Getting Started: One-Dimensional Smooth Manifolds","text":"Therefore, we can define the following function to plot the smooth manifold:","category":"page"},{"location":"smooth_one/","page":"Getting Started: One-Dimensional Smooth Manifolds","title":"Getting Started: One-Dimensional Smooth Manifolds","text":"using CairoMakie\nfunction manifold_plot(data)\n    figure = Figure()\n    axes = Axis(figure[1,1])\n    for k in eachindex(data)\n        points = Point2f.(data[k].u)\n        lines!(axes, points)\n    end\n    figure\nend\nmanifold_plot(manifold.data)","category":"page"},{"location":"smooth_one/","page":"Getting Started: One-Dimensional Smooth Manifolds","title":"Getting Started: One-Dimensional Smooth Manifolds","text":"Full codes without comments:","category":"page"},{"location":"smooth_one/","page":"Getting Started: One-Dimensional Smooth Manifolds","title":"Getting Started: One-Dimensional Smooth Manifolds","text":"using StaticArrays, LinearAlgebra, InvariantManifolds, CairoMakie\nfunction fixedpoints(p)\n    a , b = p\n    x1 = (-sqrt(4 * a + b^2 - 2 * b + 1) + b - 1) / (2 * a)\n    y1 = (1 / 2) * (b^2 / a - b * sqrt(4 * a + b^2 - 2 * b + 1) / a - b / a)\n    x2 = (sqrt(4 * a + b^2 - 2 * b + 1) + b - 1) / (2 * a)\n    y2 = (1 / 2) * (b^2 / a + b * sqrt(4 * a + b^2 - 2 * b + 1) / a - b / a)\n    return SA[x1, y1], SA[x2, y2]\nend\nfunction jacobian(x, p)\n    a, b = p\n    J = @SMatrix [-2 * a * x[1] 1.0; b 0.0]\n    return J\nend\nfunction henonmap(x, p)\n    y1 = 1 - p[1] * x[1]^2 + x[2]\n    y2 = p[2] * x[1]\n    SA[y1, y2]\nend\nfunction henonmap2(x, p)\n    henonmap(henonmap(x, p), p)\nend\npara = [1.4, 0.3]\nprob = OneDManifoldProblem(henonmap2, para)\nsaddle = fixedpoints(para)[2]\nunstable_direction = eigen(jacobian(fixedpoints([1.4, 0.3])[2], [1.4, 0.3])).vectors[:,1]\nsegment = gen_segment(saddle, unstable_direction)\nmanifold = growmanifold(prob, segment, 8)\nfunction manifold_plot(data)\n    figure = Figure()\n    axes = Axis(figure[1,1])\n    for k in eachindex(data)\n        points = Point2f.(data[k].u)\n        lines!(axes, points)\n    end\n    figure\nend\nmanifold_plot(manifold.data)","category":"page"},{"location":"smooth_one/#Oscillator-with-Periodic-Forcing","page":"Getting Started: One-Dimensional Smooth Manifolds","title":"Oscillator with Periodic Forcing","text":"","category":"section"},{"location":"smooth_one/","page":"Getting Started: One-Dimensional Smooth Manifolds","title":"Getting Started: One-Dimensional Smooth Manifolds","text":"Now let's consider a higher-order example. Consider the following oscillator with periodic forcing:","category":"page"},{"location":"smooth_one/","page":"Getting Started: One-Dimensional Smooth Manifolds","title":"Getting Started: One-Dimensional Smooth Manifolds","text":"beginaligned\ndotx=y\ndoty=x-delta x^3+gamma cos(omega t)\nendaligned","category":"page"},{"location":"smooth_one/","page":"Getting Started: One-Dimensional Smooth Manifolds","title":"Getting Started: One-Dimensional Smooth Manifolds","text":"When gamma=0, the system has a saddle point at (00). After a small periodic perturbation, this saddle point becomes a saddle periodic orbit, which is a saddle point of the mapping TXmapsto phi(X2piomega0), where phi(Xtt_0) is the solution of the system under the initial condition X(t_0)=XinmathbbR^2. Fortunately, we can obtain the Jacobian matrix of the mapping T using the solution of the variational equation. The saddle point position and unstable direction of the mapping T can also be obtained through numerical methods.","category":"page"},{"location":"smooth_one/","page":"Getting Started: One-Dimensional Smooth Manifolds","title":"Getting Started: One-Dimensional Smooth Manifolds","text":"InvariantManifolds.jl provides a function findsaddle to obtain the saddle point position and unstable direction of T. Here's the code demonstrating how to use this function:","category":"page"},{"location":"smooth_one/","page":"Getting Started: One-Dimensional Smooth Manifolds","title":"Getting Started: One-Dimensional Smooth Manifolds","text":"using InvariantManifolds, LinearAlgebra, StaticArrays, OrdinaryDiffEq, CairoMakie\nf(x, p, t) = SA[x[2], x[1] - p[1]*(x[1]^3) + p[2]*cos(p[3]*t)]\ndf(x, p, t) = SA[0.0 1.0; 1-p[1]*3*(x[1]^2) 0.0]\ninitial_guess = SA[0.0, 0.0]\npara = [1.0, 0.1, 2.2]\ntimespan = (0.0, 2pi/para[3])\nsaddle = findsaddle(f, df, timespan, initial_guess, para)","category":"page"},{"location":"smooth_one/","page":"Getting Started: One-Dimensional Smooth Manifolds","title":"Getting Started: One-Dimensional Smooth Manifolds","text":"The gen_segment function can act directly on the Saddle structure. Therefore, we can use the following code to generate a local manifold:","category":"page"},{"location":"smooth_one/","page":"Getting Started: One-Dimensional Smooth Manifolds","title":"Getting Started: One-Dimensional Smooth Manifolds","text":"segment = gen_segment(saddle)","category":"page"},{"location":"smooth_one/","page":"Getting Started: One-Dimensional Smooth Manifolds","title":"Getting Started: One-Dimensional Smooth Manifolds","text":"Now we can define the nonlinear mapping:","category":"page"},{"location":"smooth_one/","page":"Getting Started: One-Dimensional Smooth Manifolds","title":"Getting Started: One-Dimensional Smooth Manifolds","text":"function timeTmap(x, p)\n    prob = ODEProblem{false}(f, x, (0.0, 2pi/p[3]), p)\n    solve(prob, Vern9(), abstol=1e-10)[end]\nend","category":"page"},{"location":"smooth_one/","page":"Getting Started: One-Dimensional Smooth Manifolds","title":"Getting Started: One-Dimensional Smooth Manifolds","text":"Then create the problem and solve it:","category":"page"},{"location":"smooth_one/","page":"Getting Started: One-Dimensional Smooth Manifolds","title":"Getting Started: One-Dimensional Smooth Manifolds","text":"prob = OneDManifoldProblem(timeTmap, para)\nmanifold = growmanifold(prob, segment, 7)","category":"page"},{"location":"smooth_one/","page":"Getting Started: One-Dimensional Smooth Manifolds","title":"Getting Started: One-Dimensional Smooth Manifolds","text":"Finally, use the function defined in the previous section to plot the results:","category":"page"},{"location":"smooth_one/","page":"Getting Started: One-Dimensional Smooth Manifolds","title":"Getting Started: One-Dimensional Smooth Manifolds","text":"manifold_plot(manifold.data)","category":"page"},{"location":"smooth_one/","page":"Getting Started: One-Dimensional Smooth Manifolds","title":"Getting Started: One-Dimensional Smooth Manifolds","text":"Full codes without comments:","category":"page"},{"location":"smooth_one/","page":"Getting Started: One-Dimensional Smooth Manifolds","title":"Getting Started: One-Dimensional Smooth Manifolds","text":"using StaticArrays, LinearAlgebra, InvariantManifolds, CairoMakie, OrdinaryDiffEq\nf(x, p, t) = SA[x[2], x[1] - p[1]*(x[1]^3) + p[2]*cos(p[3]*t)]\ndf(x, p, t) = SA[0.0 1.0; 1-p[1]*3*(x[1]^2) 0.0]\ninitial_guess = SA[0.0, 0.0]\npara = [1.0, 0.1, 2.2]\ntimespan = (0.0, 2pi/para[3])\nsaddle = findsaddle(f, df, timespan, initial_guess, para)\nsegment = gen_segment(saddle)\nfunction timeTmap(x, p)\n    prob = ODEProblem{false}(f, x, (0.0, 2pi/p[3]), p)\n    solve(prob, Vern9(), abstol=1e-10)[end]\nend\nprob = OneDManifoldProblem(timeTmap, para)\nmanifold = growmanifold(prob, segment, 7)\nfunction manifold_plot(data)\n    figure = Figure()\n    axes = Axis(figure[1,1])\n    for k in eachindex(data)\n        points = Point2f.(data[k].u)\n        lines!(axes, points)\n    end\n    figure\nend\nmanifold_plot(manifold.data)","category":"page"},{"location":"smooth_two/#Two-Dimensional-Smooth-Manifolds","page":"Two-Dimensional Smooth Manifolds","title":"Two-Dimensional Smooth Manifolds","text":"","category":"section"},{"location":"smooth_two/","page":"Two-Dimensional Smooth Manifolds","title":"Two-Dimensional Smooth Manifolds","text":"Essentially, we haven't introduced new algorithms; the core functions for computing two-dimensional manifolds are the same as those for one-dimensional manifolds. We simply represent the two-dimensional manifold as circles of one-dimensional manifolds that are close enough to each other.","category":"page"},{"location":"smooth_two/#Autonomous-Vector-Field:-Lorenz-Manifold","page":"Two-Dimensional Smooth Manifolds","title":"Autonomous Vector Field: Lorenz Manifold","text":"","category":"section"},{"location":"smooth_two/","page":"Two-Dimensional Smooth Manifolds","title":"Two-Dimensional Smooth Manifolds","text":"First, let's load the required packages and define the Lorenz vector field:","category":"page"},{"location":"smooth_two/","page":"Two-Dimensional Smooth Manifolds","title":"Two-Dimensional Smooth Manifolds","text":"using InvariantManifolds, LinearAlgebra, StaticArrays, OrdinaryDiffEq, CairoMakie\nfunction lorenz(x, p, t)\n    σ, ρ, β = p\n    v = SA[σ*(x[2]-x[1]),\n        ρ*x[1]-x[2]-x[1]*x[3],\n        x[1]*x[2]-β*x[3]\n    ]\n    v / sqrt(0.1 + norm(v)^2)\nend","category":"page"},{"location":"smooth_two/","page":"Two-Dimensional Smooth Manifolds","title":"Two-Dimensional Smooth Manifolds","text":"It's worth noting that we performed an approximate normalization of the vector field to keep its magnitude within a small range. This ensures uniform expansion of the manifold. Under the classical parameters:","category":"page"},{"location":"smooth_two/","page":"Two-Dimensional Smooth Manifolds","title":"Two-Dimensional Smooth Manifolds","text":"para = [10.0, 28.0, 8/3]","category":"page"},{"location":"smooth_two/","page":"Two-Dimensional Smooth Manifolds","title":"Two-Dimensional Smooth Manifolds","text":"the Jacobian matrix at the origin equilibrium point has two stable directions, which are:","category":"page"},{"location":"smooth_two/","page":"Two-Dimensional Smooth Manifolds","title":"Two-Dimensional Smooth Manifolds","text":"function eigenv(p)\n    σ, ρ, β = p\n    [SA[0.0, 0.0, 1.0], SA[-(-1 + σ + sqrt(1 - 2 * σ + 4 * ρ * σ + σ^2))/(2*ρ), 1, 0]]\nend\neigenv(para)","category":"page"},{"location":"smooth_two/","page":"Two-Dimensional Smooth Manifolds","title":"Two-Dimensional Smooth Manifolds","text":"Then we can create a Saddle structure to store this saddle point:","category":"page"},{"location":"smooth_two/","page":"Two-Dimensional Smooth Manifolds","title":"Two-Dimensional Smooth Manifolds","text":"saddle = Saddle(SA[0, 0, 0.0], eigenv(para), [1.0, 1.0])","category":"page"},{"location":"smooth_two/","page":"Two-Dimensional Smooth Manifolds","title":"Two-Dimensional Smooth Manifolds","text":"The magnitude of the eigenvalues can be specified arbitrarily, as it won't affect the computation results. Since we're computing the stable manifold, we need to evolve the flow backward. Let's define the following mapping:","category":"page"},{"location":"smooth_two/","page":"Two-Dimensional Smooth Manifolds","title":"Two-Dimensional Smooth Manifolds","text":"function lorenz_map(x, p)\n    prob = ODEProblem{false}(lorenz, x, (0.0, -1.0), p)\n    sol = solve(prob, Vern9(), abstol = 1e-10)\n    sol[end]\nend","category":"page"},{"location":"smooth_two/","page":"Two-Dimensional Smooth Manifolds","title":"Two-Dimensional Smooth Manifolds","text":"Now we can create the problem:","category":"page"},{"location":"smooth_two/","page":"Two-Dimensional Smooth Manifolds","title":"Two-Dimensional Smooth Manifolds","text":"prob = VTwoDManifoldProblem(lorenz_map, para, d=1.0, amax=1.0, dsmin=1e-3)","category":"page"},{"location":"smooth_two/","page":"Two-Dimensional Smooth Manifolds","title":"Two-Dimensional Smooth Manifolds","text":"For the meaning of these keyword arguments, please refer to VTwoDManifoldProblem.","category":"page"},{"location":"smooth_two/","page":"Two-Dimensional Smooth Manifolds","title":"Two-Dimensional Smooth Manifolds","text":"Similar to one-dimensional manifolds, we need a local manifold to start the extension. The corresponding function for creating a local manifold is gen_disk:","category":"page"},{"location":"smooth_two/","page":"Two-Dimensional Smooth Manifolds","title":"Two-Dimensional Smooth Manifolds","text":"disk = gen_disk(saddle, r=1.0)","category":"page"},{"location":"smooth_two/","page":"Two-Dimensional Smooth Manifolds","title":"Two-Dimensional Smooth Manifolds","text":"For detailed information about the gen_disk function, please refer to gen_disk. Now we can proceed with the extension:","category":"page"},{"location":"smooth_two/","page":"Two-Dimensional Smooth Manifolds","title":"Two-Dimensional Smooth Manifolds","text":"manifold = growmanifold(prob, disk, 200)","category":"page"},{"location":"smooth_two/","page":"Two-Dimensional Smooth Manifolds","title":"Two-Dimensional Smooth Manifolds","text":"We can also define a plotting function to visualize the results:","category":"page"},{"location":"smooth_two/","page":"Two-Dimensional Smooth Manifolds","title":"Two-Dimensional Smooth Manifolds","text":"using CairoMakie\nfunction manifold_plot(annulus)\n    fig = Figure()\n    axes = LScene(fig[1, 1], show_axis=false, scenekw=(backgroundcolor=:white, clear=true))\n    for i in eachindex(annulus)\n        points = Point3f.(annulus[i].u)\n        lines!(axes, points, fxaa=true)\n    end\n    fig\nend\nmanifold_plot(manifold.data)","category":"page"},{"location":"smooth_two/","page":"Two-Dimensional Smooth Manifolds","title":"Two-Dimensional Smooth Manifolds","text":"Full codes without comments:","category":"page"},{"location":"smooth_two/","page":"Two-Dimensional Smooth Manifolds","title":"Two-Dimensional Smooth Manifolds","text":"using InvariantManifolds, LinearAlgebra, StaticArrays, OrdinaryDiffEq, CairoMakie\nfunction lorenz(x, p, t)\n    σ, ρ, β = p\n    v = SA[σ*(x[2]-x[1]),\n        ρ*x[1]-x[2]-x[1]*x[3],\n        x[1]*x[2]-β*x[3]\n    ]\n    v / sqrt(0.1 + norm(v)^2)\nend\nfunction eigenv(p)\n    σ, ρ, β = p\n    [SA[0.0, 0.0, 1.0], SA[-(-1 + σ + sqrt(1 - 2 * σ + 4 * ρ * σ + σ^2))/(2*ρ), 1, 0]]\nend\npara = [10.0, 28.0, 8/3]\nsaddle = Saddle(SA[0.0, 0.0, 0.0], eigenv(para), [1.0, 1.0])\nprob = VTwoDManifoldProblem(lorenz, para, d=1.0, amax=1.0, dsmin=1e-3)\ndisk = gen_disk(saddle, r=1.0)\nmanifold = growmanifold(prob, disk, 200)\nfunction manifold_plot(annulus)\n    fig = Figure()\n    axes = LScene(fig[1, 1], show_axis=false, scenekw=(backgroundcolor=:white, clear=true))\n    for i in eachindex(annulus)\n        points = Point3f.(annulus[i].u)\n        lines!(axes, points, fxaa=true)\n    end\n    fig\nend\nmanifold_plot(manifold.data)","category":"page"},{"location":"smooth_two/#Nonlinear-Mapping","page":"Two-Dimensional Smooth Manifolds","title":"Nonlinear Mapping","text":"","category":"section"},{"location":"smooth_two/","page":"Two-Dimensional Smooth Manifolds","title":"Two-Dimensional Smooth Manifolds","text":"Consider the following nonlinear mapping:","category":"page"},{"location":"smooth_two/","page":"Two-Dimensional Smooth Manifolds","title":"Two-Dimensional Smooth Manifolds","text":"f(X)=varphicircLambdacircvarphi^-1(X)","category":"page"},{"location":"smooth_two/","page":"Two-Dimensional Smooth Manifolds","title":"Two-Dimensional Smooth Manifolds","text":"where varphi(xyz)=(xyz-alpha x^2-beta y^2) is a nonlinear mapping, and Lambda is a diagonal matrix whose diagonal elements can be used to control the Jacobian matrix of mapping f near the origin. Here's the code for computing its invariant manifold:","category":"page"},{"location":"smooth_two/","page":"Two-Dimensional Smooth Manifolds","title":"Two-Dimensional Smooth Manifolds","text":"using InvariantManifolds, LinearAlgebra, StaticArrays, OrdinaryDiffEq, CairoMakie\nconst Λ = SDiagonal(SA[2.1, 6.3, 0.6])\nφ(x, p)= SA[x[1],x[2],x[3]-p[1]*x[1]^2-p[2]*x[2]^2]\niφ(x, p)= SA[x[1],x[2],x[3]+p[1]*x[1]^2+p[2]*x[2]^2]\nf(x,p) = φ(Λ*iφ(x, p),p)\n\npara = [1.2,-1.2]\nsaddle = Saddle(SA[0.0, 0.0, 0.0], [SA[1.0, 0.0, 0.0], SA[0.0, 1.0, 0.0]], [2.1, 6.3])\nprob = TwoDManifoldProblem(f, para, dcircle=0.05, d = 0.02, dsmin=1e-3)\n\ndisk = gen_disk(saddle, times=4, r= 0.05)\nmanifold = growmanifold(prob, disk, 3)\nfunction manifold_plot(data)\n    fig = Figure()\n    axes = Axis3(fig[1,1])\n    for k in eachindex(data)\n        for j in eachindex(data[k])\n            points=data[k][j].u\n            scatter!(axes,Point3f.(points),fxaa=true)\n        end\n    end\n    fig\nend\nmanifold_plot(manifold.data)","category":"page"}]
}
