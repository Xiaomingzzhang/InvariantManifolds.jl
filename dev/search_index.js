var documenterSearchIndex = {"docs":
[{"location":"non_smooth_one/#One-Dimensional-Non-Smooth-Manifolds","page":"非光滑一维流形","title":"One-Dimensional Non-Smooth Manifolds","text":"","category":"section"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"Perhaps the most notable feature of this package is its ability to compute non-smooth manifolds. Currently, it supports the computation of non-smooth manifolds for two types of systems:","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"One-dimensional manifold computation for time-periodic non-smooth differential equations\nTwo-dimensional manifold computation for non-smooth autonomous systems","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"The manifolds in both cases are invariant manifolds of saddle points. The former requires taking time-periodic mappings, while the latter requires taking fixed-step time-T-mappings. The non-smooth factors in these two types of systems can be diverse, including piecewise smooth functions, collisions, and combinations thereof. Users don't need to solve these three types of non-smooth systems themselves, as we provide three encapsulated structures:","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"PiecewiseV\nBilliardV\nPiecewiseImpactV","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"We use the Callback functionality from OrdinaryDiffEq.jl to compute time mappings. The following three examples will demonstrate the methods for computing invariant manifolds of these three types of non-smooth systems.","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"warning: Warning\nThe computation of non-smooth manifolds heavily depends on the ODE solving algorithm and precision. When the solution fails or performs poorly, try changing the algorithm, increasing the ODE solving precision, or reducing the values of parameters ϵ, d, amax in NSOneDManifoldProblem.","category":"page"},{"location":"non_smooth_one/#Piecewise-Smooth-Systems","page":"非光滑一维流形","title":"Piecewise Smooth Systems","text":"","category":"section"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"Consider a simple piecewise smooth system:","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"beginaligned\ndotx=y\ndoty=f(x) + epsilon sin(2pi t)\nendaligned","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"where","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"f(x) =\nbegincases\n-k_1 x textif  x  -d\nk_2 x  textif  -dxd\n-k_3 x textif  x  d\nendcases","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"k_1k_2k_3d0","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"are all positive constants. We will compute the invariant manifold of the time-periodic mapping. Note that when the periodic perturbation is small, the saddle point should be close to the origin.","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"First, let's load the required packages","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"using InvariantManifolds, LinearAlgebra, StaticArrays, OrdinaryDiffEq, CairoMakie","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"using InvariantManifolds, LinearAlgebra, StaticArrays, OrdinaryDiffEq, CairoMakie","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"Next, define the piecewise smooth vector field:","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"f1(x, p, t) = SA[x[2], p[1]*x[1]+p[4]*sin(2pi * t)]\nf2(x, p, t) = SA[x[2], -p[2]*x[1]+p[4]*sin(2pi * t)]\nf3(x, p, t) = SA[x[2], -p[3]*x[1]+p[4]*sin(2pi * t)]\n\nhyper1(x, p, t) = x[1] - p[5]\nhyper2(x, p, t) = x[1] + p[5]\n\ndom1(x, p, t) = -p[5] < x[1] < p[5]\ndom2(x, p, t) = x[1] > p[5]\ndom3(x, p, t) = x[1] < -p[5]\n\nvectorfield = PiecewiseV((f1, f2, f3), (dom1, dom2, dom3), (hyper1, hyper2))","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"The parameters passed to the PiecewiseV structure are: vector fields, their domains, and the hyperplanes that divide these domains. For more details, refer to PiecewiseV.","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"Next, we'll encapsulate the key information for solving the time-periodic mapping in another structure NSSetUp:","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"setup = setmap(vectorfield, (0.0, 1.0), Tsit5(), abstol=1e-8)","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"The function setmap is used to encapsulate the time mapping computation information. Now we have defined everything needed to solve the time-periodic mapping.","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"Next, to generate the local manifold, we also need to locate the saddle point and its unstable eigenvector. Let's set the parameters:","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"para = para = [2, 5, 5, 0.6, 2]","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"Since the perturbation is small, the saddle-type periodic orbit should still be in dom1. Therefore, we can use findsaddle to calculate the position of the saddle point:","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"function df1(x, p, t)\n    SA[0 1; p[1] 0]\nend\ninitialguess = SA[0.0, 0.0]\nsaddle = findsaddle(f1, df1, (0.0,1.0), initialguess, para, abstol=1e-10)","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"Next, create the problem, generate the local manifold, and perform the extension","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"prob = NSOneDManifoldProblem(setup, para, ϵ = 1e-3)\nsegment = gen_segment(saddle)\nmanifold = growmanifold(prob, segment, 8)","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"Note that the data type of manifold.data is Vector{Vector{S}}, where S is an interpolation function. So we need to use the following function to plot the results:","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"using CairoMakie\nfunction manifold_plot(data)\n    fig = Figure()\n    axes = Axis(fig[1,1])\n    for k in eachindex(data)\n        for j in eachindex(data[k])\n            points=data[k][j].u\n            lines!(axes,first.(points),last.(points))\n        end\n    end\n    fig\nend\nmanifold_plot(manifold.data)","category":"page"},{"location":"non_smooth_one/#Impact-Systems","page":"非光滑一维流形","title":"Impact Systems","text":"","category":"section"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"Consider the following forced inverted pendulum equation:","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"beginaligned\ndotx= y\ndoty= sin(x) - epsilon cos(2pi t)\nendaligned","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"Assume there are walls on both sides of the inverted pendulum: when x=xi or x=-xi, we have yrightarrow - ry. Similarly, we need to first construct the non-smooth vector field","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"using InvariantManifolds, LinearAlgebra, StaticArrays, OrdinaryDiffEq, CairoMakie\nfunction manifold_plot(data)\n    fig = Figure()\n    axes = Axis(fig[1,1])\n    for k in eachindex(data)\n        for j in eachindex(data[k])\n            points=data[k][j].u\n            lines!(axes,first.(points),last.(points))\n        end\n    end\n    fig\nend","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"f(x, p, t) = SA[x[2], sin(x[1])-p[1]*cos(2 * pi * t)]\n\nhyper1(x, p, t) = x[1] + p[2]\nhyper2(x, p, t) = x[1] - p[2]\n\nrule1(x, p, t) = SA[x[1], -p[3]*x[2]]\nrule2(x, p, t) = SA[x[1], -p[3]*x[2]]\n\nvectorfield = BilliardV(f, (hyper1, hyper2), (rule1, rule2))","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"Next, encapsulate the information for solving the time-periodic mapping:","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"setup = setmap(vectorfield, (0.0, 1.0), Vern9(), abstol=1e-10)","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"Find the saddle point:","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"function df(x, p, t)\n    SA[0 1; cos(x[1]) 0]\nend\npara = [0.2, pi / 4, 0.98]\ninitialguess = SA[0.0, 0.0]\nsaddle = findsaddle(f, df, (0.0,1.0), initialguess, para, abstol=1e-10)","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"Next, create the problem, generate the local manifold, and perform the extension","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"prob = NSOneDManifoldProblem(setup, para)\nsegment = gen_segment(saddle)\nmanifold = growmanifold(prob, segment, 11)","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"Finally, plot the results: ","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"manifold_plot(manifold.data)","category":"page"},{"location":"non_smooth_one/#Combined-Piecewise-Smooth-and-Impact-ODE-Systems","page":"非光滑一维流形","title":"Combined Piecewise Smooth and Impact ODE Systems","text":"","category":"section"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"using InvariantManifolds, LinearAlgebra, StaticArrays, OrdinaryDiffEq, CairoMakie\nfunction manifold_plot(data)\n    fig = Figure()\n    axes = Axis(fig[1,1])\n    for k in eachindex(data)\n        for j in eachindex(data[k])\n            points=data[k][j].u\n            lines!(axes,first.(points),last.(points))\n        end\n    end\n    fig\nend","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"Now consider an ODE system with both piecewise smooth functions and impacts:","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"beginaligned\ndotx=y\ndoty=f(x) + epsilon sin(2pi t)\nendaligned","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"where","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"f(x) =\nbegincases\n-k_1 x textif  x  -d\nk_2 x  textif  -dxd\nendcases","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"k_1k_2d0","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"are all positive constants. When x=d, we have doty--rdoty. We will compute the invariant manifold of the time-periodic mapping. Note that when the periodic perturbation is small, the saddle point should be close to the origin. First, let's load the required packages","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"using InvariantManifolds, LinearAlgebra, StaticArrays, OrdinaryDiffEq, CairoMakie","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"using InvariantManifolds, LinearAlgebra, StaticArrays, OrdinaryDiffEq, CairoMakie","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"Next, define the non-smooth vector field:","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"f1(x, p, t) = SA[x[2], p[1]*x[1]+p[3]*sin(2pi * t)]\nf2(x, p, t) = SA[x[2], -p[2]*x[1]+p[3]*sin(2pi * t)]\n\nhyper1(x, p, t) = x[1] - p[4]\nhyper2(x, p, t) = x[1] + p[4]\n\ndom1(x, p, t) = -p[4] < x[1] < p[4]\ndom2(x, p, t) = x[1] < -p[4]\n\nimpact_rule(x, p, t) = SA[x[1], -p[5]*x[2]]\nid(x,p,t) = x\n\nvectorfield = PiecewiseImpactV((f1, f2), (dom1, dom2), (hyper1, hyper2), (impact_rule, id), [1])","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"The parameters passed to the PiecewiseImpactV structure are: vector fields, their domains, the hyperplanes that divide these domains, the rules that act on the hyperplanes, and a list of rules that have impact effects. For more details, refer to PiecewiseImpactV.","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"Next, we'll encapsulate the key information for solving the time-periodic mapping in another structure NSSetUp:","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"setup = setmap(vectorfield, (0.0, 1.0), Tsit5(), abstol=1e-8)","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"The function setmap is used to encapsulate the time mapping computation information. Now we have defined everything needed to solve the time-periodic mapping.","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"Next, to generate the local manifold, we also need to locate the saddle point and its unstable eigenvector. Let's set the parameters:","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"para = [2, 5, 0.6, 2, 0.98]","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"Since the perturbation is small, the saddle-type periodic orbit should still be in dom1. Therefore, we can use findsaddle to calculate the position of the saddle point:","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"function df1(x, p, t)\n    SA[0 1; p[1] 0]\nend\ninitialguess = SA[0.0, 0.0]\nsaddle = findsaddle(f1, df1, (0.0,1.0), initialguess, para, abstol=1e-10)","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"Next, create the problem, generate the local manifold, and perform the extension","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"prob = NSOneDManifoldProblem(setup, para, ϵ = 1e-3)\nsegment = gen_segment(saddle)\nmanifold = growmanifold(prob, segment, 9)","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"Note that the data type of manifold.data is Vector{Vector{S}}, where S is an interpolation function. So we need to use the following function to plot the results:","category":"page"},{"location":"non_smooth_one/","page":"非光滑一维流形","title":"非光滑一维流形","text":"using CairoMakie\nfunction manifold_plot(data)\n    fig = Figure()\n    axes = Axis(fig[1,1])\n    for k in eachindex(data)\n        for j in eachindex(data[k])\n            points=data[k][j].u\n            lines!(axes,first.(points),last.(points))\n        end\n    end\n    fig\nend\nmanifold_plot(manifold.data)","category":"page"},{"location":"api/#API","page":"类型与函数","title":"API","text":"","category":"section"},{"location":"api/","page":"类型与函数","title":"类型与函数","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api/","page":"类型与函数","title":"类型与函数","text":"Modules = [InvariantManifolds]\nOrder   = [:type, :function]","category":"page"},{"location":"api/#InvariantManifolds.BilliardV","page":"类型与函数","title":"InvariantManifolds.BilliardV","text":"BilliardV\n\nA callable struct to represent a vector field with multiple hyper surfaces such that the flow jump when hits these hyper surfaces.\n\nFields\n\nf is the vector field, of type f(x,p,t), and its output is a SVector;\nhypers is tuple of hyper surfaces:(h1,h2,...), h1(x,p,t);\nirules is tuple of rules on hyper surfaces:(r1,r2,r3,...).\n\n\n\n\n\n","category":"type"},{"location":"api/#InvariantManifolds.FlawPoint","page":"类型与函数","title":"InvariantManifolds.FlawPoint","text":"FlawPoint{N,T}\n\nFlawPoint is a struct to record the points that don't satisfy the angle and distance request while the  program has reached the minimum arc length.\n\nFields\n\npoint flaw point in the process of continuation;\nα the angle recorded;\nd the distance recorded.\n\n\n\n\n\n","category":"type"},{"location":"api/#InvariantManifolds.NSOneDManifold","page":"类型与函数","title":"InvariantManifolds.NSOneDManifold","text":"NSOneDManifold{F,S,N,T}\n\nNSOneDManifold is a struct contains all the information of the non-smooth one-dimensional numerical manifold.\n\nFields\n\nprob the problem NSOneDManifoldProblem;\ndata the numerical data that should be Vector{Vector{Vector{S}}}, where S is the interpolation curve (we use DataInterpolation in this package);\nflawpoints the flaw points generated during continuation.\n\n\n\n\n\n","category":"type"},{"location":"api/#InvariantManifolds.NSOneDManifoldProblem","page":"类型与函数","title":"InvariantManifolds.NSOneDManifoldProblem","text":"NSOneDManifoldProblem{F,T}\n\nNSOneDManifoldProblem is a struct to contain the main information for continuing the non-smooth one-dimensional manifold of the time-T-map of a non-smooth ODE.\n\nFields\n\nf the struct NSSetUp;\npara the parameters of the nonlinear map;\namax the maximum angle between points when continuing the manifold;\nd the maximum distance between points when continuing the manifold;\nϵ the max value of the following expression: maxH(x_0T)H(x_1T) where H(xt) is the hypersurface the manifold cross, x_0 and x_1 are points before and after the cross, T is the end of the time-T-map (from 0 to T).\ndsmin the minimum arc length allowing; note that if in a continuation point, this value is achieved and the angle as well as the distance values are not achieved, then we will record this point as a FlawPoint.\n\nConvenient consturctors are NSOneDManifoldProblem(f) and NSOneDManifoldProblem(f,para)\n\n\n\n\n\n","category":"type"},{"location":"api/#InvariantManifolds.NSSetUp","page":"类型与函数","title":"InvariantManifolds.NSSetUp","text":"NSSetUp{T}\n\nNSSetUp is a struct to contain all the information needed in continuing the manifold of non-smooth ODE.\n\nFields\n\nf the Non-smooth vector field, like PiecewiseV;\ntimespan the time span of time-T-map;\ntimetmap the time-t-map of non-smooth ODE, which maps a NSState and parameters of ODE to a NSState.\n\n\n\n\n\n","category":"type"},{"location":"api/#InvariantManifolds.NSSolution","page":"类型与函数","title":"InvariantManifolds.NSSolution","text":"NSSolution{N,T<:Number}\n\nThe NSSolution is a struct to contain all information of the solution of a non-smooth ODE system.\n\nFields\n\nsol ODESolution solved by OrdinaryDiffEq;\nevent_t the times when events happen;\nevent_state the solution's state when events happen;\nevent_at is a vector that contains integers indicating which event happen.\n\n\n\n\n\n","category":"type"},{"location":"api/#InvariantManifolds.NSState","page":"类型与函数","title":"InvariantManifolds.NSState","text":"NSState{N,T<:Number} <: AbstractVector{T}\n\nThe struct NSState is to record the events data for a time-T-map.\n\nFields\n\nstate the final state of the time-T-map;\nevent_at is a integer vector that contains the history of the events happened.\n\nThe construction of NSState allows to interpolate vectors consisting of NSState. Currently, LinearInterpolation, CubicSpline, and QuadraticInterpolation in DataInterpolations.jl are supported.\n\n\n\n\n\n","category":"type"},{"location":"api/#InvariantManifolds.NSVTwoDManifold","page":"类型与函数","title":"InvariantManifolds.NSVTwoDManifold","text":"NSVTwoDManifold{F,S,N,T}\n\nNSVTwoDManifold is a struct contains all the information of the non-smooth two-dimensional numerical manifold of an autonomous vector field.\n\nFields\n\nprob the problem NSVTwoDManifoldProblem;\ndata the numerical data that should be Vector{Vector{S}}, where S is the interpolation curve (we use DataInterpolation in this package);\nflawpoints the flaw points generated during continuation.\n\n\n\n\n\n","category":"type"},{"location":"api/#InvariantManifolds.NSVTwoDManifoldProblem","page":"类型与函数","title":"InvariantManifolds.NSVTwoDManifoldProblem","text":"NSVTwoDManifoldProblem{F,T}\n\nNSVTwoDManifoldProblemVTwoDManifoldProblem is a struct to contain the main information for continuing the two-dimensional manifold of an autonomous vector field.\n\nFields\n\nf the NSSetUp of a nonsmooth vector field;\npara the parameters of the time flow map;\namax the maximum angle between points when continuing the manifold;\nd the maximum distance between points when continuing the manifold;\nϵ the max value of the following expression: maxH(x_0T)H(x_1T) where H(xt) is the hypersurface of the manifold cross, x_0 and x_1 are points before and after the cross, T is the end of the time-T-map (from 0 to T).\ndsmin the minimum arc length allowing; note that if in a continuation point, this value is achieved and the angle as well as the distance values are not achieved, then we will record this point as a FlawPoint.\n\nConvenient consturctors are NSVTwoDManifoldProblem(f) and NSVTwoDManifoldProblem(f,para)\n\n\n\n\n\n","category":"type"},{"location":"api/#InvariantManifolds.ODESolver","page":"类型与函数","title":"InvariantManifolds.ODESolver","text":"ODESolver{F1,F2,T}\n\nA wrapper struct for solving ordinary differential equations (ODEs).\n\nFields\n\nf: Vector field function of the ODE system in the form f(x,p,t)\ntimespan: Time interval for solving the ODE, of type Tuple{T,T}\nalg: The numerical algorithm used for solving the ODE\nabstol: Absolute tolerance for the numerical solver\n\n\n\n\n\n","category":"type"},{"location":"api/#InvariantManifolds.OneDManifold","page":"类型与函数","title":"InvariantManifolds.OneDManifold","text":"OneDManifold{F,S,N,T}\n\nOneDManifold is a struct contains all the information of the one-dimensional numerical manifold.\n\nFields\n\nprob the problem OneDManifoldProblem;\ndata the numerical data that should be Vector{Vector{S}}, where S is the interpolation curve (we use DataInterpolation in this package);\nflawpoints the flaw points generated during continuation.\n\n\n\n\n\n","category":"type"},{"location":"api/#InvariantManifolds.OneDManifoldProblem","page":"类型与函数","title":"InvariantManifolds.OneDManifoldProblem","text":"OneDManifoldProblem{F,T}\n\nOneDManifoldProblem is a struct to contain the main information for continuing the one-dimensional manifold of a nonlinear map.\n\nFields\n\nf the nonlinear map, which should has the form f(x,p) and return a SVector;\npara the parameters of the nonlinear map;\namax the maximum angle between points when continuing the manifold;\nd the maximum distance between points when continuing the manifold;\ndsmin the minimum arc length allowing; note that if in a continuation point, this value is achieved and the angle as well as the distance values are not achieved, then we will record this point as a FlawPoint.\n\nConvenient consturctors are OneDManifoldProblem(f) and OneDManifoldProblem(f,para)\n\n\n\n\n\n","category":"type"},{"location":"api/#InvariantManifolds.PiecewiseImpactV","page":"类型与函数","title":"InvariantManifolds.PiecewiseImpactV","text":"PiecewiseImpactV\n\nA callable struct to represent a vector field with both piecewise non-smoothness and impacts.\n\nfs is a tuple of smooth vector fields in different regions.\nregions is a tuple of the region functions: (r1,r2,...), where r1(x,p,t) should return a Bool value to indicate that x is in this region or not.\nhypers is a tuple of the hyper surfaces separating the regions.\nrules is a tuple of rules on hyper surfaces:(r1,r2,r3,...). Note that for hypersurfaces that only switch between two vector fields, we can set r1=id.\nidxs is a vector of integer to indicate hypersurfaces with impact effects.\nn is a integer to switch between vector fields. Default to be zero.\n\n\n\n\n\n","category":"type"},{"location":"api/#InvariantManifolds.PiecewiseV","page":"类型与函数","title":"InvariantManifolds.PiecewiseV","text":"PiecewiseV\n\nA callable struct to represent a piecewise smooth vector field. \n\nFields\n\nfs is a tuple of smooth vector fields in different regions.\nregions is a tuple of the region functions: (r1,r2,...), where r1(x,p,t) should return a Bool value to indicate that x is in this region or not.\nhypers is a tuple of the hyper surfaces separating the regions.\nn is a integer to switch between vector fields. Default to be zero.\n\nExample\n\nusing StaticArrays, InvariantManifolds\nf1(x,p,t)=SA[x[2],-2x[1]]\nf2(x,p,t)=SA[x[2],-x[1]]\ndom1(x,p,t)=x[1]>0\ndom2(x,p,t)=x[2]<0\nhyper(x,p,t)=x[1]\nPiecewiseV((f1,f2),(dom1,dom2),(hyper,))\n\nThe above codes generate a piecewise smooth vector field, which when x[1]>0 is f1, and when x[2]<0 is f2. The hyper surface separating these smooth vector fields is x[1]=0.\n\n\n\n\n\n","category":"type"},{"location":"api/#InvariantManifolds.Saddle","page":"类型与函数","title":"InvariantManifolds.Saddle","text":"Saddle{N,T,S}\n\nSaddle is a struct to contain the information of a saddle point needed in continuing the manifold of non-smooth ODE. For an ODE's saddle, this struct can be constructed by the function findsaddle.\n\nFields\n\nsaddle the location of the saddle point;\nunstable_directions the unstable directions;\nunstable_eigen_values eigenvalues of the linearized map in the saddle at the unstable eigenvectors.\n\n\n\n\n\n","category":"type"},{"location":"api/#InvariantManifolds.TwoDManifold","page":"类型与函数","title":"InvariantManifolds.TwoDManifold","text":"TwoDManifold{F,S,N,T}\n\nTwoDManifold is a struct contains all the information of the two-dimensional numerical manifold of a nonlinear map.\n\nFields\n\nprob the problem TwoDManifoldProblem;\ndata the numerical data that should be Vector{S}, where S is the interpolation curve (we use DataInterpolation in this package);\nflawpoints the flaw points generated during continuation.\n\n\n\n\n\n","category":"type"},{"location":"api/#InvariantManifolds.TwoDManifoldProblem","page":"类型与函数","title":"InvariantManifolds.TwoDManifoldProblem","text":"TwoDManifoldProblem{F,T}\n\nTwoDManifoldProblem is a struct to contain the main information for continuing the two-dimensional manifold of a nonlinear map.\n\nFields\n\nf the nonlinear map, which should has the form f(x,p) and return a SVector;\npara the parameters of the nonlinear map;\namax the maximum angle between points when continuing the manifold;\nd the maximum distance between points when continuing the manifold;\ndcircle the maximum distance between circles when continuing the manifold;\ndsmin the minimum arc length allowing; note that if in a continuation point, this value is achieved and the angle as well as the distance values are not achieved, then we will record this point as a FlawPoint.\n\nConvenient consturctors are TwoDManifoldProblem(f) and TwoDManifoldProblem(f,para)\n\n\n\n\n\n","category":"type"},{"location":"api/#InvariantManifolds.VTwoDManifold","page":"类型与函数","title":"InvariantManifolds.VTwoDManifold","text":"VTwoDManifold{F,S,N,T}\n\nVTwoDManifold is a struct contains all the information of the two-dimensional numerical manifold of an autonomous vector field.\n\nFields\n\nprob the problem VTwoDManifoldProblem;\ndata the numerical data that should be Vector{S}, where S is the interpolation curve (we use DataInterpolation in this package);\nflawpoints the flaw points generated during continuation.\n\n\n\n\n\n","category":"type"},{"location":"api/#InvariantManifolds.VTwoDManifoldProblem","page":"类型与函数","title":"InvariantManifolds.VTwoDManifoldProblem","text":"VTwoDManifoldProblem{F,T}\n\nVTwoDManifoldProblem is a struct to contain the main information for continuing the two-dimensional manifold of an autonomous vector field.\n\nFields\n\nf the time flow map of the vector field, which should has the form f(x,p) and return a SVector; note that the vector field should be regularized, e.g., dotx=v(x) should be rewritten as dotx=v(x)sqrt1+v(x);\npara the parameters of the time flow map;\namax the maximum angle between points when continuing the manifold;\nd the maximum distance between points when continuing the manifold;\ndsmin the minimum arc length allowing; note that if in a continuation point, this value is achieved and the angle as well as the distance values are not achieved, then we will record this point as a FlawPoint.\n\nConvenient consturctors are VTwoDManifoldProblem(f) and VTwoDManifoldProblem(f,para)\n\n\n\n\n\n","category":"type"},{"location":"api/#InvariantManifolds.addcircles!-NTuple{8, Any}","page":"类型与函数","title":"InvariantManifolds.addcircles!","text":"InvariantManifolds.addcircles!(f, para, d, circles, dsmin, αmax, dcircle, flawpoints; interp=LinearInterpolation)\n\nAdds and refines circles in the two-dimensional manifold computation by iterating the map and ensuring proper point distribution.\n\nArguments\n\nf: The nonlinear map function\npara: Vector of parameters for the map\nd: Maximum allowed distance between points in a circle\ncircles: Vector of interpolated curves representing the current circles\ndsmin: Minimum allowed arc length between points\nαmax: Maximum allowed angle between consecutive points\ndcircle: Maximum allowed distance between consecutive circles\nflawpoints: Vector to store problematic points during computation\ninterp: Interpolation method (default: LinearInterpolation)\n\nReturns\n\nA vector of new interpolated curves representing the refined circles after one iteration of the map.\n\nDetails\n\nThe function performs two main steps:\n\nIterates each circle forward under the map and refines point distribution within each circle\nAdds intermediate circles where the distance between consecutive circles exceeds dcircle\n\nPoints are added to maintain proper spacing and curvature constraints specified by d and αmax.\n\n\n\n\n\n","category":"method"},{"location":"api/#InvariantManifolds.addpoints!-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Any, Any, Array{StaticArraysCore.SVector{N, T}, 1}, Vector{T}, Any, Any, Any}} where {N, T}","page":"类型与函数","title":"InvariantManifolds.addpoints!","text":"InvariantManifolds.addpoints!(f, p, d, oldcurve, newu, olds, dsmin, αmax, flawpoints)\n\nAdd points to ensure proper spacing and curvature along a one-dimensional manifold curve.\n\nArguments\n\nf: The nonlinear map function\np: Parameters for the nonlinear map\nd: Maximum allowed distance between consecutive points\noldcurve: Previous curve interpolation\nnewu::Vector{SVector{N,T}}: New points to be processed\nolds::Vector{T}: Parameter values of the points\ndsmin: Minimum allowed arc length between points\nαmax: Maximum allowed angle between consecutive segments\nflawpoints: Vector to store problematic points that don't meet criteria\n\nDetails\n\nThe function iteratively processes points, adding new ones when:\n\nThe distance between consecutive points exceeds d\nThe angle between consecutive segments exceeds αmax\nThe arc length is greater than dsmin\n\nIf a point fails these criteria and the minimum arc length is reached, it's recorded as a flaw point.\n\nReturns\n\nVector of parameter values for the new points\n\n\n\n\n\n","category":"method"},{"location":"api/#InvariantManifolds.findsaddle-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Any, StaticArraysCore.SVector{N, T}, Any}} where {N, T}","page":"类型与函数","title":"InvariantManifolds.findsaddle","text":"findsaddle(v, dv, timespan, x, p)\n\nfindsaddle is a function to find the saddle of the time-T-map of smooth ODE systems, by using the Newton's method.\n\nParameters\n\nv the vector field, which should be the form f(x,p,t) and return a SVector;\ndv the Jacobi matrix function of v, which should should be the form dv(x,p,t) and return a SMatrix;\ntimespan the time span of the time-T-map;\nx the initial point to iterate.\n\nKeyword arguments\n\nn maximum iterate times, default to be 100;\nabstol absolute tolerance for the fixed point, default to be 1e-8;\nalg the algorithm used to solve the ODE, default to be Vern9().\n\nReturns\n\nA Saddle object, which contains the fixed point and the directions of the stable manifold.\n\n\n\n\n\n","category":"method"},{"location":"api/#InvariantManifolds.gen_disk-Union{Tuple{Saddle{N, T, S}}, Tuple{S}, Tuple{T}, Tuple{N}} where {N, T, S}","page":"类型与函数","title":"InvariantManifolds.gen_disk","text":"gen_disk(p, times)\n\ngen_disk is a function to generate circles around the saddle, which represented as the local manifold.\n\nParameters\n\np the struct Saddle which should contains two unstable directions; the complex eigenvalues and eigenvectors are allowed.\n\nKeyword arguments\n\ntimes the iteration time, default to be 1; for the computation of invariant manifolds of nonlinear map, this parameter is needed to adjust the torsion in different directions in the process of continuation.\nn the number of point in each circle, default to be 150;\nd the max distance between points in a single circle, default to be 0.0002;\nr the size of the disk, default to be 0.05;\ncircles the number of the circles, default to be 10.\n\n\n\n\n\n","category":"method"},{"location":"api/#InvariantManifolds.gen_segment-Union{Tuple{T}, Tuple{N}, Tuple{StaticArraysCore.SVector{N, T}, Any}} where {N, T}","page":"类型与函数","title":"InvariantManifolds.gen_segment","text":"gen_segment(saddle, direction)\n\nGenerating n points at saddle in the direction, with length d, with default n=150 and d=0.01. Another Convenient consturctor is gen_segment(p::Saddle).\n\n\n\n\n\n","category":"method"},{"location":"api/#InvariantManifolds.grow!-Tuple{InvariantManifolds.OneDManifold}","page":"类型与函数","title":"InvariantManifolds.grow!","text":"grow!(manifold)\n\nOne time iteration to grow the manifold.\n\nParameters\n\nmanifold the manifold struct.\n\nKeyword argument\n\ninterp the interpolation method used, default to be LinearInterpolation.\n\n\n\n\n\n","category":"method"},{"location":"api/#InvariantManifolds.growmanifold-Tuple{OneDManifoldProblem, Any, Any}","page":"类型与函数","title":"InvariantManifolds.growmanifold","text":"growmanifold(prob, points, N)\n\nThis is the mani function to continuate the numerical manifolds. Its output is a manifold struct.\n\nParameters\n\nprob the problem such as OneDManifoldProblem.\npoints the points in the local manifold. For one dimensional manifolds, these points should be a Vector{SVector} and the start point should be the saddle. For two dimensional manifolds, these points should be a Vector{Vector{S}} and its first element should like [saddle, saddle, saddle]. Note that in the both cases, the functions gen_segment and gen_disk can generate these points easily.\nN the number of iterations.\n\nKeyword argument\n\ninterp the interpolation method used, default to be LinearInterpolation.\n\n\n\n\n\n","category":"method"},{"location":"api/#InvariantManifolds.initialize-Union{Tuple{T}, Tuple{N}, Tuple{OneDManifoldProblem, Array{StaticArraysCore.SVector{N, T}, 1}}} where {N, T}","page":"类型与函数","title":"InvariantManifolds.initialize","text":"initialize(prob, points)\n\nThis is a function to initialize the continuation process. Its output is a manifold struct.\n\nParameters\n\nprob the problem such as OneDManifoldProblem.\npoints the points in the local manifold. For one dimensional manifolds, these points should be a Vector{SVector} and the start point should be the saddle. For two dimensional manifolds, these points should be a Vector{Vector{S}} and its first element should like [saddle, saddle, saddle]. Note that in the both cases, the functions gen_segment and gen_disk can generate these points easily.\n\nKeyword argument\n\ninterp the interpolation method used, default to be LinearInterpolation.\n\n\n\n\n\n","category":"method"},{"location":"api/#InvariantManifolds.kd_distence-Union{Tuple{T}, Tuple{N}, Tuple{StaticArraysCore.SVector{N, T}, Array{StaticArraysCore.SVector{N, T}, 1}}} where {N, T}","page":"类型与函数","title":"InvariantManifolds.kd_distence","text":"InvariantManifolds.kd_distence\n\nThe function to measure the distance between two circles by using the package NearestNeighbors.jl.\n\n\n\n\n\n","category":"method"},{"location":"api/#InvariantManifolds.ns_addpoints!-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Any, Any, Any, Array{NSState{N, T}, 1}, Vector{T}, Vararg{Any, 5}}} where {N, T}","page":"类型与函数","title":"InvariantManifolds.ns_addpoints!","text":"InvariantManifolds.ns_addpoints!(tmap, p, d, dsmin, oldcurve, newu, olds, αmax, tend, hypers, ϵ, flawpoints) -> Vector{T}\n\nAdd points to ensure proper spacing and accuracy when computing the non-smooth one-dimensional manifold.\n\nArguments\n\ntmap: Time map function that evolves states forward\np: Vector of parameters\nd: Maximum allowed distance between consecutive points\ndsmin: Minimum allowed arc length between points\noldcurve: Previous curve data used for interpolation\nnewu: Vector of new states to be processed\nolds: Vector of arc length parameters\nαmax: Maximum allowed angle between consecutive segments\ntend: End time of the time map\nhypers: Vector of hypersurface functions\nϵ: Maximum allowed error in hypersurface intersection\nflawpoints: Vector to store problematic points encountered\n\nReturns\n\nVector of arc length parameters for the processed points\n\nDetails\n\nThe function adaptively adds points to maintain:\n\nMaximum distance d between consecutive points\nMaximum angle αmax between segments\nAccuracy ϵ at hypersurface intersections\n\nIf constraints cannot be satisfied within dsmin, points are marked as flaws.\n\n\n\n\n\n","category":"method"},{"location":"api/#InvariantManifolds.ns_solver-Tuple{PiecewiseV, Vararg{Any, 4}}","page":"类型与函数","title":"InvariantManifolds.ns_solver","text":"ns_solver(v::T, para, timespan, alg, N, T)\n\nThe function ns_solver is similar to timetmap. The output of this function is a function which maps a SVector to a NSSolution. This NSSolution contain all data of an non-smooth ODE solution.\n\nParameters\n\nv vector fields like PiecewiseV or BilliardV.\npara the parameter of the vector field.\ntimespan the time span of the time-T-map.\nalg algorithm in OrdinaryDiffEq to solve ODE.\nN the dimension of the vector field.\nT number type used in computation.\n\nTo ensure type stable, the numbers in para and timespan should be type of T. The last two parameters have to be specified, since we need to store the event data. You can also pass the keywords of solve of OrdinaryDiffEq to this function,  except the callback and saving related keywords.\n\n\n\n\n\n","category":"method"},{"location":"api/#InvariantManifolds.set_distence-Union{Tuple{T}, Tuple{N}, Tuple{Array{StaticArraysCore.SVector{N, T}, 1}, Array{StaticArraysCore.SVector{N, T}, 1}}} where {N, T}","page":"类型与函数","title":"InvariantManifolds.set_distence","text":"InvariantManifolds.set_distence\n\nThe function to measure the distance between two sets by using the package NearestNeighbors.jl.\n\n\n\n\n\n","category":"method"},{"location":"api/#InvariantManifolds.setmap-Union{Tuple{T}, Tuple{PiecewiseV, Tuple{T, T}, Any}} where T","page":"类型与函数","title":"InvariantManifolds.setmap","text":"setmap(v, timespan::Tuple{T,T}, alg; extra...) where {T}\n\nThe function setmap is to get a NSSetUp.\n\nParameters\n\nv a nonsmooth vector field like PiecewiseV or BilliardV.\ntimespan the time span of the time-T-map.\nalg algorithm in OrdinaryDiffEq to solve ODE.\n\nTo ensure type stable, the numbers in timespan should be type of T.\n\nKeyword arguments\n\nFor vector fields PiecewiseV and PiecewiseImpactV, we have two special keyword arguments:\n\ncross_time= 1//20 when the solution sol hits the hypersurface at time t, we need to know which domain it enters. We choose the state sol(t+cross_time) to determine which domain it enters.\nregion_detect=_region_detect the region detect function to determine which domain the state in.\n\nYou can also pass the keywords of solve of OrdinaryDiffEq to this function,  except the callback and saving related keywords.\n\n\n\n\n\n","category":"method"},{"location":"non_smooth_two/#Non-smooth-two-dimensional-manifold-for-non-smooth-autonomous-vector-field","page":"非光滑两维流形","title":"Non-smooth two-dimensional manifold for non-smooth autonomous vector field","text":"","category":"section"},{"location":"#InvariantManifolds.jl","page":"主页","title":"InvariantManifolds.jl","text":"","category":"section"},{"location":"","page":"主页","title":"主页","text":"This package aims to provide a convenient tool for numerically investigating low-dimensional invariant manifolds. We offer no guarantees regarding numerical stability or reliability.","category":"page"},{"location":"","page":"主页","title":"主页","text":"Main idea:","category":"page"},{"location":"","page":"主页","title":"主页","text":"The core concept of this package is straightforward. By utilizing the local manifolds of saddle points, we progressively extend these manifolds. We maintain points in close proximity (controlled by distance and curvature) to ensure the accuracy of the numerical manifolds.","category":"page"},{"location":"","page":"主页","title":"主页","text":"In this package, the two-dimensional algorithm for smooth mappings is built upon the one-dimensional algorithm. Numerical manifolds are represented as a collection of sufficiently close points, forming circles.","category":"page"},{"location":"","page":"主页","title":"主页","text":"The most compelling aspect of this package lies in its ability to reliably compute non-smooth invariant manifolds. Please refer to the examples for further details.","category":"page"},{"location":"smooth_one/","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"using InvariantManifolds, StaticArrays, OrdinaryDiffEq, CairoMakie","category":"page"},{"location":"smooth_one/","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"# Getting Started: One-Dimensional Smooth Manifolds\n\n## Nonlinear Mapping\nConsider the following Henon map:\n","category":"page"},{"location":"smooth_one/","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"math \\begin{aligned} x'&=1-\\alpha x^2+y,\\\ny'&=\\beta x, \\end{aligned}","category":"page"},{"location":"smooth_one/","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"\nwhere $\\alpha,\\beta$ are parameters. This mapping has fixed points:\n","category":"page"},{"location":"smooth_one/","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"math \\begin{aligned} (x1,y1)&=(\\frac{-\\sqrt{4 \\alpha +\\beta ^2-2 \\beta +1}+\\beta -1}{2 \\alpha },\\frac{1}{2} \\left(\\frac{\\beta ^2}{\\alpha }-\\frac{\\beta  \\sqrt{4 \\alpha +\\beta ^2-2 \\beta +1}}{\\alpha }-\\frac{\\beta }{\\alpha }\\right)),\\\n(x2,y2)&=(\\frac{\\sqrt{4 \\alpha +\\beta ^2-2 \\beta +1}+\\beta -1}{2 \\alpha },\\frac{1}{2} \\left(\\frac{\\beta ^2}{\\alpha }+\\frac{\\beta  \\sqrt{4 \\alpha +\\beta ^2-2 \\beta +1}}{\\alpha }-\\frac{\\beta }{\\alpha }\\right)), \\end{aligned}","category":"page"},{"location":"smooth_one/","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"\nLet's calculate the eigenvalues of these two fixed points under the classical parameters $\\alpha=1.4,\\beta=0.3$:\n","category":"page"},{"location":"smooth_one/","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"@example smooth_one using StaticArrays, LinearAlgebra function fixedpoints(p)     a , b = p     x1 = (-sqrt(4 * a + b^2 - 2 * b + 1) + b - 1) / (2 * a)     y1 = (1 / 2) * (b^2 / a - b * sqrt(4 * a + b^2 - 2 * b + 1) / a - b / a)     x2 = (sqrt(4 * a + b^2 - 2 * b + 1) + b - 1) / (2 * a)     y2 = (1 / 2) * (b^2 / a + b * sqrt(4 * a + b^2 - 2 * b + 1) / a - b / a)     return SA[x1, y1], SA[x2, y2] end","category":"page"},{"location":"smooth_one/","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"function jacobian(x, p)     a, b = p     J = @SMatrix [-2 * a * x[1] 1.0; b 0.0]     return J end","category":"page"},{"location":"smooth_one/","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"","category":"page"},{"location":"smooth_one/","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"@repl smooth_one eigen(jacobian(fixedpoints([1.4, 0.3])[1], [1.4, 0.3]))","category":"page"},{"location":"smooth_one/","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"","category":"page"},{"location":"smooth_one/","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"@repl smooth_one eigen(jacobian(fixedpoints([1.4, 0.3])[2], [1.4, 0.3]))","category":"page"},{"location":"smooth_one/","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"\nAs we can see, under the classical parameters, both fixed points are unstable. Next, we'll use the InvariantManifolds.jl package to compute one branch of the unstable manifold of the second fixed point.\n\nThe InvariantManifolds.jl package has an interface similar to many Julia packages. First, we need to load the package in Julia and define the Henon map:\n","category":"page"},{"location":"smooth_one/","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"@repl smooth_one using InvariantManifolds function henonmap(x, p)     y1 = 1 - p[1] * x[1]^2 + x[2]     y2 = p[2] * x[1]     SA[y1, y2] end","category":"page"},{"location":"smooth_one/","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"\nSince the unstable eigenvalue at the saddle point is:","category":"page"},{"location":"smooth_one/","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"@repl smooth_one eigen(jacobian(fixedpoints([1.4, 0.3])[2], [1.4, 0.3])).values[1]","category":"page"},{"location":"smooth_one/","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"We need to iterate this mapping twice to ensure the manifold doesn't reverse during extension:\n","category":"page"},{"location":"smooth_one/","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"@repl smooth_one henonmap2(x, p)=henonmap(henonmap(x, p), p)","category":"page"},{"location":"smooth_one/","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"\nNow let's define a problem for computing a one-dimensional manifold of the smooth mapping:\n","category":"page"},{"location":"smooth_one/","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"@repl smooth_one para = [1.4, 0.3] prob = OneDManifoldProblem(henonmap2, para)","category":"page"},{"location":"smooth_one/","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"\nTo compute the manifold, we need a small local manifold segment starting at the saddle point. Usually, an unstable eigenvector starting at the saddle point with a very small length will suffice. InvariantManifolds.jl provides a function [`gen_segment`](@ref) to generate such a local manifold:\n","category":"page"},{"location":"smooth_one/","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"@example smoothone saddle = fixedpoints(para)[2] unstabledirection = eigen(jacobian(fixedpoints([1.4, 0.3])[2], [1.4, 0.3])).vectors[:,1] segment = gensegment(saddle, unstabledirection)","category":"page"},{"location":"smooth_one/","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"\nUnder default keyword arguments, this function will generate a local manifold starting at the saddle point, with a length of 150 units and a step size of 0.01. Now let's use this local manifold to compute the smooth manifold:\n","category":"page"},{"location":"smooth_one/","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"@repl smooth_one manifold = growmanifold(prob, segment, 8)","category":"page"},{"location":"smooth_one/","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"\nThis package doesn't provide plotting functionality. However, since the computation results are stored in `manifold.data`, and `manifold.data` is actually a vector whose elements are interpolation functions from the [DataInterpolations.jl](https://github.com/SciML/DataInterpolations.jl) package:","category":"page"},{"location":"smooth_one/","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"@repl smooth_one manifold.data","category":"page"},{"location":"smooth_one/","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"\nTherefore, we can define the following function to plot the smooth manifold:\n","category":"page"},{"location":"smooth_one/","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"@example smoothone using CairoMakie function manifoldplot(data)     figure = Figure()     axes = Axis(figure[1,1])     for k in eachindex(data)         points = data[k].u         lines!(axes, first.(points), last.(points))     end     figure end manifold_plot(manifold.data)","category":"page"},{"location":"smooth_one/","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"\n## Oscillator with Periodic Forcing\n\nNow let's consider a higher-order example. Consider the following oscillator with periodic forcing:","category":"page"},{"location":"smooth_one/","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"math \\begin{aligned} \\dot{x}&=y,\\\n\\dot{y}&=x-\\delta x^3+\\gamma \\cos(\\omega t). \\end{aligned}","category":"page"},{"location":"smooth_one/","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"\nWhen $\\gamma=0$, the system has a saddle point at $(0,0)$. After a small periodic perturbation, this saddle point becomes a saddle periodic orbit, which is a saddle point of the mapping $T:X\\mapsto \\phi(X,2\\pi/\\omega,0)$, where $\\phi(X,t,t_0)$ is the solution of the system under the initial condition $X(t_0)=X\\in\\mathbb{R}^2$. Fortunately, we can obtain the Jacobian matrix of the mapping $T$ using the solution of the variational equation. The saddle point position and unstable direction of the mapping $T$ can also be obtained through numerical methods.\n\nInvariantManifolds.jl provides a function [`findsaddle`](@ref) to obtain the saddle point position and unstable direction of $T$. Here's the code demonstrating how to use this function:\n","category":"page"},{"location":"smooth_one/","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"@example smoothone using InvariantManifolds, LinearAlgebra, StaticArrays, OrdinaryDiffEq, CairoMakie f(x, p, t) = SA[x[2], x[1] - p[1](x[1]^3) + p[2]cos(p[3]t)] df(x, p, t) = SA[0.0 1.0; 1-p[1]3*(x[1]^2) 0.0] initialguess = SA[0.0, 0.0] para = [1.0, 0.1, 2.2] timespan = (0.0, 2pi/para[3]) saddle = findsaddle(f, df, timespan, initial_guess, para)","category":"page"},{"location":"smooth_one/","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"\nThe `gen_segment` function can act directly on the [`Saddle`](@ref) structure. Therefore, we can use the following code to generate a local manifold:","category":"page"},{"location":"smooth_one/","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"@repl smoothone segment = gensegment(saddle)","category":"page"},{"location":"smooth_one/","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"\nNow we can define the nonlinear mapping:","category":"page"},{"location":"smooth_one/","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"@repl smooth_one function timeTmap(x, p)     prob = ODEProblem{false}(f, x, (0.0, 2pi/p[3]), p)     solve(prob, Vern9(), abstol=1e-10)[end] end","category":"page"},{"location":"smooth_one/","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"\nThen create the problem and solve it:","category":"page"},{"location":"smooth_one/","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"@repl smooth_one prob = OneDManifoldProblem(timeTmap, para) manifold = growmanifold(prob, segment, 7)","category":"page"},{"location":"smooth_one/","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"Finally, use the function defined in the previous section to plot the results:","category":"page"},{"location":"smooth_one/","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"@example smoothone manifoldplot(manifold.data) ```","category":"page"},{"location":"smooth_two/#Two-Dimensional-Smooth-Manifolds","page":"光滑两维流形","title":"Two-Dimensional Smooth Manifolds","text":"","category":"section"},{"location":"smooth_two/","page":"光滑两维流形","title":"光滑两维流形","text":"Essentially, we haven't introduced new algorithms; the core functions for computing two-dimensional manifolds are the same as those for one-dimensional manifolds. We simply represent the two-dimensional manifold as circles of one-dimensional manifolds that are close enough to each other.","category":"page"},{"location":"smooth_two/","page":"光滑两维流形","title":"光滑两维流形","text":"using InvariantManifolds, LinearAlgebra, StaticArrays, OrdinaryDiffEq, CairoMakie","category":"page"},{"location":"smooth_two/#Autonomous-Vector-Field:-Lorenz-Manifold","page":"光滑两维流形","title":"Autonomous Vector Field: Lorenz Manifold","text":"","category":"section"},{"location":"smooth_two/","page":"光滑两维流形","title":"光滑两维流形","text":"First, let's load the required packages and define the Lorenz vector field:","category":"page"},{"location":"smooth_two/","page":"光滑两维流形","title":"光滑两维流形","text":"using InvariantManifolds, LinearAlgebra, StaticArrays, OrdinaryDiffEq, CairoMakie\nfunction lorenz(x, p, t)\n    σ, ρ, β = p\n    v = SA[σ*(x[2]-x[1]),\n        ρ*x[1]-x[2]-x[1]*x[3],\n        x[1]*x[2]-β*x[3]\n    ]\n    v / sqrt(0.1 + norm(v)^2)\nend","category":"page"},{"location":"smooth_two/","page":"光滑两维流形","title":"光滑两维流形","text":"It's worth noting that we performed an approximate normalization of the vector field to keep its magnitude within a small range. This ensures uniform expansion of the manifold. Under the classical parameters:","category":"page"},{"location":"smooth_two/","page":"光滑两维流形","title":"光滑两维流形","text":"para = [10.0, 28.0, 8/3]","category":"page"},{"location":"smooth_two/","page":"光滑两维流形","title":"光滑两维流形","text":"the Jacobian matrix at the origin equilibrium point has two stable directions, which are:","category":"page"},{"location":"smooth_two/","page":"光滑两维流形","title":"光滑两维流形","text":"function eigenv(p)\n    σ, ρ, β = p\n    [SA[0.0, 0.0, 1.0], SA[-(-1 + σ + sqrt(1 - 2 * σ + 4 * ρ * σ + σ^2))/(2*ρ), 1, 0]]\nend\neigenv(para)","category":"page"},{"location":"smooth_two/","page":"光滑两维流形","title":"光滑两维流形","text":"Then we can create a Saddle structure to store this saddle point:","category":"page"},{"location":"smooth_two/","page":"光滑两维流形","title":"光滑两维流形","text":"saddle = Saddle(SA[0, 0, 0.0], eigenv(para), [1.0, 1.0])","category":"page"},{"location":"smooth_two/","page":"光滑两维流形","title":"光滑两维流形","text":"The magnitude of the eigenvalues can be specified arbitrarily, as it won't affect the computation results. Since we're computing the stable manifold, we need to evolve the flow backward. Let's define the following mapping:","category":"page"},{"location":"smooth_two/","page":"光滑两维流形","title":"光滑两维流形","text":"function lorenz_map(x, p)\n    prob = ODEProblem{false}(lorenz, x, (0.0, -1.0), p)\n    sol = solve(prob, Vern9(), abstol = 1e-10)\n    sol[end]\nend","category":"page"},{"location":"smooth_two/","page":"光滑两维流形","title":"光滑两维流形","text":"Now we can create the problem:","category":"page"},{"location":"smooth_two/","page":"光滑两维流形","title":"光滑两维流形","text":"prob = VTwoDManifoldProblem(lorenz_map, para, d=1.0, amax=1.0, dsmin=1e-3)","category":"page"},{"location":"smooth_two/","page":"光滑两维流形","title":"光滑两维流形","text":"For the meaning of these keyword arguments, please refer to VTwoDManifoldProblem.","category":"page"},{"location":"smooth_two/","page":"光滑两维流形","title":"光滑两维流形","text":"Similar to one-dimensional manifolds, we need a local manifold to start the extension. The corresponding function for creating a local manifold is gen_disk:","category":"page"},{"location":"smooth_two/","page":"光滑两维流形","title":"光滑两维流形","text":"disk = gen_disk(saddle, r=1.0)","category":"page"},{"location":"smooth_two/","page":"光滑两维流形","title":"光滑两维流形","text":"For detailed information about the gen_disk function, please refer to gen_disk. Now we can proceed with the extension:","category":"page"},{"location":"smooth_two/","page":"光滑两维流形","title":"光滑两维流形","text":"manifold = growmanifold(prob, disk, 200)","category":"page"},{"location":"smooth_two/","page":"光滑两维流形","title":"光滑两维流形","text":"We can also define a plotting function to visualize the results:","category":"page"},{"location":"smooth_two/","page":"光滑两维流形","title":"光滑两维流形","text":"using CairoMakie\nfunction manifold_plot(annulus)\n    fig = Figure()\n    axes = LScene(fig[1, 1], show_axis=false, scenekw=(backgroundcolor=:white, clear=true))\n    second(x) = x[2]\n    for i in eachindex(annulus)\n        points = annulus[i].u\n        lines!(axes, first.(points), second.(points), last.(points), fxaa=true)\n    end\n    fig\nend\nmanifold_plot(manifold.data)","category":"page"},{"location":"smooth_two/#Nonlinear-Mapping","page":"光滑两维流形","title":"Nonlinear Mapping","text":"","category":"section"},{"location":"smooth_two/","page":"光滑两维流形","title":"光滑两维流形","text":"Consider the following nonlinear mapping:","category":"page"},{"location":"smooth_two/","page":"光滑两维流形","title":"光滑两维流形","text":"f(X)=varphicircLambdacircvarphi^-1(X)","category":"page"},{"location":"smooth_two/","page":"光滑两维流形","title":"光滑两维流形","text":"where varphi(xyz)=(xyz-alpha x^2-beta y^2) is a nonlinear mapping, and Lambda is a diagonal matrix whose diagonal elements can be used to control the Jacobian matrix of mapping f near the origin. Here's the code for computing its invariant manifold:","category":"page"},{"location":"smooth_two/","page":"光滑两维流形","title":"光滑两维流形","text":"using InvariantManifolds, LinearAlgebra, StaticArrays, OrdinaryDiffEq, CairoMakie\nΛ = SDiagonal(SA[2.1, 6.3, 0.6])\nφ(x, p)= SA[x[1],x[2],x[3]-p[1]*x[1]^2-p[2]*x[2]^2]\niφ(x, p)= SA[x[1],x[2],x[3]+p[1]*x[1]^2+p[2]*x[2]^2]\nf(x,p) = φ(Λ*iφ(x, p),p)\n\npara = [1.2,-1.2]\nsaddle = Saddle(SA[0.0, 0.0, 0.0], [SA[1.0, 0.0, 0.0], SA[0.0, 1.0, 0.0]], [2.1, 6.3])\nprob = TwoDManifoldProblem(f, para, dcircle=0.05, d = 0.02, dsmin=1e-3)\n\ndisk = gen_disk(saddle, times=4, r= 0.05)\nmanifold = growmanifold(prob, disk, 3)\nfunction manifold_plot(data)\n    fig = Figure()\n    axes = Axis3(fig[1,1])\n    second(x) = x[2]\n    for k in eachindex(data)\n        for j in eachindex(data[k])\n            points=data[k][j].u\n            scatter!(axes,first.(points),second.(points),last.(points),fxaa=true)\n        end\n    end\n    fig\nend\nmanifold_plot(manifold.data)","category":"page"}]
}
