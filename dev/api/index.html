<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · InvariantManifolds.jl</title><meta name="title" content="API · InvariantManifolds.jl"/><meta property="og:title" content="API · InvariantManifolds.jl"/><meta property="twitter:title" content="API · InvariantManifolds.jl"/><meta name="description" content="Documentation for InvariantManifolds.jl."/><meta property="og:description" content="Documentation for InvariantManifolds.jl."/><meta property="twitter:description" content="Documentation for InvariantManifolds.jl."/><meta property="og:url" content="https://Xiaomingzzhang.github.io/InvariantManifolds.jl/api/"/><meta property="twitter:url" content="https://Xiaomingzzhang.github.io/InvariantManifolds.jl/api/"/><link rel="canonical" href="https://Xiaomingzzhang.github.io/InvariantManifolds.jl/api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="InvariantManifolds.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">InvariantManifolds.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../smooth_one/">Getting Started: One-Dimensional Smooth Manifolds</a></li><li><a class="tocitem" href="../smooth_two/">Two-Dimensional Smooth Manifolds</a></li><li><a class="tocitem" href="../non_smooth_one/">One-Dimensional Non-Smooth Manifolds</a></li><li><a class="tocitem" href="../non_smooth_two/">Two-dimensional Non-Smooth Manifolds</a></li><li class="is-active"><a class="tocitem" href>API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Xiaomingzzhang/InvariantManifolds.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Xiaomingzzhang/InvariantManifolds.jl/blob/master/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><ul><li><a href="#InvariantManifolds.BilliardV"><code>InvariantManifolds.BilliardV</code></a></li><li><a href="#InvariantManifolds.FlawPoint"><code>InvariantManifolds.FlawPoint</code></a></li><li><a href="#InvariantManifolds.NSOneDManifold"><code>InvariantManifolds.NSOneDManifold</code></a></li><li><a href="#InvariantManifolds.NSOneDManifoldProblem"><code>InvariantManifolds.NSOneDManifoldProblem</code></a></li><li><a href="#InvariantManifolds.NSSetUp"><code>InvariantManifolds.NSSetUp</code></a></li><li><a href="#InvariantManifolds.NSSolution"><code>InvariantManifolds.NSSolution</code></a></li><li><a href="#InvariantManifolds.NSState"><code>InvariantManifolds.NSState</code></a></li><li><a href="#InvariantManifolds.NSVTwoDManifold"><code>InvariantManifolds.NSVTwoDManifold</code></a></li><li><a href="#InvariantManifolds.NSVTwoDManifoldProblem"><code>InvariantManifolds.NSVTwoDManifoldProblem</code></a></li><li><a href="#InvariantManifolds.ODESolver"><code>InvariantManifolds.ODESolver</code></a></li><li><a href="#InvariantManifolds.OneDManifold"><code>InvariantManifolds.OneDManifold</code></a></li><li><a href="#InvariantManifolds.OneDManifoldProblem"><code>InvariantManifolds.OneDManifoldProblem</code></a></li><li><a href="#InvariantManifolds.PiecewiseImpactV"><code>InvariantManifolds.PiecewiseImpactV</code></a></li><li><a href="#InvariantManifolds.PiecewiseV"><code>InvariantManifolds.PiecewiseV</code></a></li><li><a href="#InvariantManifolds.Saddle"><code>InvariantManifolds.Saddle</code></a></li><li><a href="#InvariantManifolds.TwoDManifold"><code>InvariantManifolds.TwoDManifold</code></a></li><li><a href="#InvariantManifolds.TwoDManifoldProblem"><code>InvariantManifolds.TwoDManifoldProblem</code></a></li><li><a href="#InvariantManifolds.VTwoDManifold"><code>InvariantManifolds.VTwoDManifold</code></a></li><li><a href="#InvariantManifolds.VTwoDManifoldProblem"><code>InvariantManifolds.VTwoDManifoldProblem</code></a></li><li><a href="#InvariantManifolds.addcircles!-NTuple{8, Any}"><code>InvariantManifolds.addcircles!</code></a></li><li><a href="#InvariantManifolds.addpoints!-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Any, Any, Array{StaticArraysCore.SVector{N, T}, 1}, Vector{T}, Any, Any, Any}} where {N, T}"><code>InvariantManifolds.addpoints!</code></a></li><li><a href="#InvariantManifolds.findsaddle-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Any, StaticArraysCore.SVector{N, T}, Any}} where {N, T}"><code>InvariantManifolds.findsaddle</code></a></li><li><a href="#InvariantManifolds.gen_disk-Union{Tuple{Saddle{N, T, S}}, Tuple{S}, Tuple{T}, Tuple{N}} where {N, T, S}"><code>InvariantManifolds.gen_disk</code></a></li><li><a href="#InvariantManifolds.gen_segment-Union{Tuple{T}, Tuple{N}, Tuple{StaticArraysCore.SVector{N, T}, Any}} where {N, T}"><code>InvariantManifolds.gen_segment</code></a></li><li><a href="#InvariantManifolds.grow!-Tuple{InvariantManifolds.OneDManifold}"><code>InvariantManifolds.grow!</code></a></li><li><a href="#InvariantManifolds.growmanifold-Tuple{OneDManifoldProblem, Any, Any}"><code>InvariantManifolds.growmanifold</code></a></li><li><a href="#InvariantManifolds.initialize-Union{Tuple{T}, Tuple{N}, Tuple{OneDManifoldProblem, Array{StaticArraysCore.SVector{N, T}, 1}}} where {N, T}"><code>InvariantManifolds.initialize</code></a></li><li><a href="#InvariantManifolds.iscontact-Union{Tuple{S}, Tuple{T}, Tuple{N}, Tuple{Any, Saddle{N, T, S}, Any}} where {N, T, S}"><code>InvariantManifolds.iscontact</code></a></li><li><a href="#InvariantManifolds.kd_distence-Union{Tuple{T}, Tuple{N}, Tuple{StaticArraysCore.SVector{N, T}, Array{StaticArraysCore.SVector{N, T}, 1}}} where {N, T}"><code>InvariantManifolds.kd_distence</code></a></li><li><a href="#InvariantManifolds.ns_addpoints!-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Any, Any, Any, Any, Array{NSState{N, T}, 1}, Vector{T}, Vararg{Any, 5}}} where {N, T}"><code>InvariantManifolds.ns_addpoints!</code></a></li><li><a href="#InvariantManifolds.ns_solver-Tuple{PiecewiseV, Vararg{Any, 4}}"><code>InvariantManifolds.ns_solver</code></a></li><li><a href="#InvariantManifolds.setmap-Union{Tuple{T}, Tuple{PiecewiseV, Tuple{T, T}, Any}} where T"><code>InvariantManifolds.setmap</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantManifolds.BilliardV" href="#InvariantManifolds.BilliardV"><code>InvariantManifolds.BilliardV</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BilliardV</code></pre><p>A callable struct to represent a vector field with multiple hyper surfaces such that the flow jump when hits these hyper surfaces.</p><p><strong>Fields</strong></p><ul><li><code>f</code> is the vector field, of type <code>f(x,p,t)</code>, and its output is a SVector;</li><li><code>hypers</code> is tuple of hyper surfaces:<code>(h1,h2,...)</code>, <code>h1(x,p,t)</code>;</li><li><code>rules</code> is tuple of rules on hyper surfaces:<code>(r1,r2,r3,...)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Xiaomingzzhang/InvariantManifolds.jl/blob/37da36cde53160039ab4c125941862d274694a3e/src/basic_constructors.jl#L62-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantManifolds.FlawPoint" href="#InvariantManifolds.FlawPoint"><code>InvariantManifolds.FlawPoint</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FlawPoint{N,T}</code></pre><p><code>FlawPoint</code> is a struct to record the points that don&#39;t satisfy the angle and distance request while the  program has reached the minimum arc length.</p><p><strong>Fields</strong></p><ul><li><code>point</code> flaw point in the process of continuation;</li><li><code>α</code> the angle recorded;</li><li><code>d</code> the distance recorded.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Xiaomingzzhang/InvariantManifolds.jl/blob/37da36cde53160039ab4c125941862d274694a3e/src/smooth-one.jl#L52-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantManifolds.NSOneDManifold" href="#InvariantManifolds.NSOneDManifold"><code>InvariantManifolds.NSOneDManifold</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NSOneDManifold{F,S,N,T}</code></pre><p><code>NSOneDManifold</code> is a struct contains all the information of the non-smooth one-dimensional numerical manifold.</p><p><strong>Fields</strong></p><ul><li><code>prob</code> the problem <a href="#InvariantManifolds.NSOneDManifoldProblem"><code>NSOneDManifoldProblem</code></a>;</li><li><code>data</code> the numerical data that should be <code>Vector{Vector{Vector{S}}}</code>, where <code>S</code> is the interpolation curve (we use <code>DataInterpolation</code> in this package);</li><li><code>flawpoints</code> the flaw points generated during continuation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Xiaomingzzhang/InvariantManifolds.jl/blob/37da36cde53160039ab4c125941862d274694a3e/src/nonsmooth-one.jl#L72-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantManifolds.NSOneDManifoldProblem" href="#InvariantManifolds.NSOneDManifoldProblem"><code>InvariantManifolds.NSOneDManifoldProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NSOneDManifoldProblem{F,T}</code></pre><p><code>NSOneDManifoldProblem</code> is a struct to contain the main information for continuing the non-smooth one-dimensional manifold of the time-T-map of a non-smooth ODE.</p><p><strong>Fields</strong></p><ul><li><code>f</code> the struct <a href="#InvariantManifolds.NSSetUp"><code>NSSetUp</code></a>;</li><li><code>distance_f</code> the distance function between two points with different events. This function should be the form <code>distance_f(idx, u0, u1)</code>, where <code>idx</code> is the index of the hypersurface, <code>u0</code> and <code>u1</code> are the points before and after the cross. The default is <code>max(abs(hypers[idx](u0, para, tend)), abs(hypers[idx](u1, para, tend)))</code>, where <code>para</code> is the parameters of the system, <code>tend</code> is the end of the time-<span>$T$</span>-map.</li><li><code>para</code> the parameters of the nonlinear map;</li><li><code>amax</code> the maximum angle between points when continuing the manifold;</li><li><code>d</code> the maximum distance between points when continuing the manifold;</li><li><code>ϵ</code> the max value of the following expression: <span>$\max\{|H(x_0,T)|,H(x_1,T)\},$</span> where <span>$H(x,t)$</span> is the hypersurface the manifold cross, <span>$x_0$</span> and <span>$x_1$</span> are points before and after the cross, <span>$T$</span> is the end of the time-<span>$T$</span>-map (from 0 to <span>$T$</span>).</li><li><code>dsmin</code> the minimum arc length allowing; note that if in a continuation point, this value is achieved and the angle as well as the distance values are not achieved, then we will record this point as a <a href="#InvariantManifolds.FlawPoint"><code>FlawPoint</code></a>.</li></ul><p>Convenient consturctors are <code>NSOneDManifoldProblem(f)</code> and <code>NSOneDManifoldProblem(f,para)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Xiaomingzzhang/InvariantManifolds.jl/blob/37da36cde53160039ab4c125941862d274694a3e/src/nonsmooth-one.jl#L2-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantManifolds.NSSetUp" href="#InvariantManifolds.NSSetUp"><code>InvariantManifolds.NSSetUp</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NSSetUp{T}</code></pre><p><code>NSSetUp</code> is a struct to contain all the information needed in continuing the manifold of non-smooth ODE.</p><p><strong>Fields</strong></p><ul><li><code>f</code> the Non-smooth vector field, like <a href="#InvariantManifolds.PiecewiseV"><code>PiecewiseV</code></a>;</li><li><code>timespan</code> the time span of time-T-map;</li><li><code>timetmap</code> the time-t-map of non-smooth ODE, which maps a <a href="#InvariantManifolds.NSState"><code>NSState</code></a> and parameters of ODE to a <a href="#InvariantManifolds.NSState"><code>NSState</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Xiaomingzzhang/InvariantManifolds.jl/blob/37da36cde53160039ab4c125941862d274694a3e/src/basic_constructors.jl#L130-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantManifolds.NSSolution" href="#InvariantManifolds.NSSolution"><code>InvariantManifolds.NSSolution</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NSSolution{N,T&lt;:Number}</code></pre><p>The <code>NSSolution</code> is a struct to contain all information of the solution of a non-smooth ODE system.</p><p><strong>Fields</strong></p><ul><li><code>sol</code> <code>ODESolution</code> solved by <code>OrdinaryDiffEq</code>;</li><li><code>event_t</code> the times when events happen;</li><li><code>event_state</code> the solution&#39;s state when events happen;</li><li><code>event_at</code> is a vector that contains integers indicating which event happen.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Xiaomingzzhang/InvariantManifolds.jl/blob/37da36cde53160039ab4c125941862d274694a3e/src/basic_constructors.jl#L157-L167">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantManifolds.NSState" href="#InvariantManifolds.NSState"><code>InvariantManifolds.NSState</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NSState{N,T&lt;:Number} &lt;: AbstractVector{T}</code></pre><p>The struct <code>NSState</code> is to record the events data for a time-T-map.</p><p><strong>Fields</strong></p><ul><li><code>state</code> the final state of the time-T-map;</li><li><code>event_at</code> is a integer vector that contains the history of the events happened.</li></ul><p>The construction of <code>NSState</code> allows to interpolate vectors consisting of <code>NSState</code>. Currently, <code>LinearInterpolation</code>, <code>CubicSpline</code>, and <code>QuadraticInterpolation</code> in DataInterpolations.jl are supported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Xiaomingzzhang/InvariantManifolds.jl/blob/37da36cde53160039ab4c125941862d274694a3e/src/nsstate_construction.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantManifolds.NSVTwoDManifold" href="#InvariantManifolds.NSVTwoDManifold"><code>InvariantManifolds.NSVTwoDManifold</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NSVTwoDManifold{F,S,N,T}</code></pre><p><code>NSVTwoDManifold</code> is a struct contains all the information of the non-smooth two-dimensional numerical manifold of an autonomous vector field.</p><p><strong>Fields</strong></p><ul><li><code>prob</code> the problem <a href="#InvariantManifolds.NSVTwoDManifoldProblem"><code>NSVTwoDManifoldProblem</code></a>;</li><li><code>data</code> the numerical data that should be <code>Vector{Vector{S}}</code>, where <code>S</code> is the interpolation curve (we use <code>DataInterpolation</code> in this package);</li><li><code>flawpoints</code> the flaw points generated during continuation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Xiaomingzzhang/InvariantManifolds.jl/blob/37da36cde53160039ab4c125941862d274694a3e/src/nonsmooth_vectorfield_two.jl#L69-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantManifolds.NSVTwoDManifoldProblem" href="#InvariantManifolds.NSVTwoDManifoldProblem"><code>InvariantManifolds.NSVTwoDManifoldProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NSVTwoDManifoldProblem{F,T}</code></pre><p><code>NSVTwoDManifoldProblemVTwoDManifoldProblem</code> is a struct to contain the main information for continuing the two-dimensional manifold of an autonomous vector field.</p><p><strong>Fields</strong></p><ul><li><code>f</code> the <code>NSSetUp</code> of a nonsmooth vector field;</li><li><code>distance_f</code> the distance function between two points with different events. This function should be the form <code>distance_f(idx, u0, u1)</code>, where <code>idx</code> is the index of the hypersurface, <code>u0</code> and <code>u1</code> are the points before and after the cross. The default is <code>max(abs(hypers[idx](u0, para, tend)), abs(hypers[idx](u1, para, tend)))</code>, where <code>para</code> is the parameters of the system, <code>tend</code> is the end of the time-<span>$T$</span>-map.</li><li><code>para</code> the parameters of the time flow map;</li><li><code>amax</code> the maximum angle between points when continuing the manifold;</li><li><code>d</code> the maximum distance between points when continuing the manifold;</li><li><code>ϵ</code> the max value of the following expression: <span>$\max\{|H(x_0,T)|,H(x_1,T)\},$</span> where <span>$H(x,t)$</span> is the hypersurface of the manifold cross, <span>$x_0$</span> and <span>$x_1$</span> are points before and after the cross, <span>$T$</span> is the end of the time-<span>$T$</span>-map (from 0 to <span>$T$</span>).</li><li><code>dsmin</code> the minimum arc length allowing; note that if in a continuation point, this value is achieved and the angle as well as the distance values are not achieved, then we will record this point as a <a href="#InvariantManifolds.FlawPoint"><code>FlawPoint</code></a>.</li></ul><p>Convenient consturctors are <code>NSVTwoDManifoldProblem(f)</code> and <code>NSVTwoDManifoldProblem(f,para)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Xiaomingzzhang/InvariantManifolds.jl/blob/37da36cde53160039ab4c125941862d274694a3e/src/nonsmooth_vectorfield_two.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantManifolds.ODESolver" href="#InvariantManifolds.ODESolver"><code>InvariantManifolds.ODESolver</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ODESolver{F1,F2,T}</code></pre><p>A wrapper struct for solving ordinary differential equations (ODEs).</p><p><strong>Fields</strong></p><ul><li><code>f</code>: Vector field function of the ODE system in the form <code>f(x,p,t)</code></li><li><code>timespan</code>: Time interval for solving the ODE, of type <code>Tuple{T,T}</code></li><li><code>alg</code>: The numerical algorithm used for solving the ODE</li><li><code>abstol</code>: Absolute tolerance for the numerical solver</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Xiaomingzzhang/InvariantManifolds.jl/blob/37da36cde53160039ab4c125941862d274694a3e/src/newton.jl#L10-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantManifolds.OneDManifold" href="#InvariantManifolds.OneDManifold"><code>InvariantManifolds.OneDManifold</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OneDManifold{F,S,N,T}</code></pre><p><code>OneDManifold</code> is a struct contains all the information of the one-dimensional numerical manifold.</p><p><strong>Fields</strong></p><ul><li><code>prob</code> the problem <a href="#InvariantManifolds.OneDManifoldProblem"><code>OneDManifoldProblem</code></a>;</li><li><code>data</code> the numerical data that should be <code>Vector{Vector{S}}</code>, where <code>S</code> is the interpolation curve (we use <code>DataInterpolation</code> in this package);</li><li><code>flawpoints</code> the flaw points generated during continuation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Xiaomingzzhang/InvariantManifolds.jl/blob/37da36cde53160039ab4c125941862d274694a3e/src/smooth-one.jl#L69-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantManifolds.OneDManifoldProblem" href="#InvariantManifolds.OneDManifoldProblem"><code>InvariantManifolds.OneDManifoldProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OneDManifoldProblem{F,T}</code></pre><p><code>OneDManifoldProblem</code> is a struct to contain the main information for continuing the one-dimensional manifold of a nonlinear map.</p><p><strong>Fields</strong></p><ul><li><code>f</code> the nonlinear map, which should has the form <code>f(x,p)</code> and return a <code>SVector</code>;</li><li><code>para</code> the parameters of the nonlinear map;</li><li><code>amax</code> the maximum angle between points when continuing the manifold;</li><li><code>d</code> the maximum distance between points when continuing the manifold;</li><li><code>dsmin</code> the minimum arc length allowing; note that if in a continuation point, this value is achieved and the angle as well as the distance values are not achieved, then we will record this point as a <a href="#InvariantManifolds.FlawPoint"><code>FlawPoint</code></a>.</li></ul><p>Convenient consturctors are <code>OneDManifoldProblem(f)</code> and <code>OneDManifoldProblem(f,para)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Xiaomingzzhang/InvariantManifolds.jl/blob/37da36cde53160039ab4c125941862d274694a3e/src/smooth-one.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantManifolds.PiecewiseImpactV" href="#InvariantManifolds.PiecewiseImpactV"><code>InvariantManifolds.PiecewiseImpactV</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PiecewiseImpactV</code></pre><p>A callable struct to represent a vector field with both piecewise non-smoothness and impacts.</p><ul><li><code>fs</code> is a tuple of smooth vector fields in different regions.</li><li><code>regions</code> is a tuple of the region functions: <code>(r1,r2,...)</code>, where <code>r1(x,p,t)</code> should return a Bool value to indicate that <code>x</code> is in this region or not.</li><li><code>hypers</code> is a tuple of the hyper surfaces separating the regions.</li><li><code>rules</code> is a tuple of rules on hyper surfaces:<code>(r1,r2,r3,...)</code>. Note that for hypersurfaces that only switch between two vector fields, we can set <code>r1=id</code>.</li><li><code>idxs</code> is a vector of integer to indicate hypersurfaces with impact effects.</li><li><code>n</code> is a integer to switch between vector fields. Default to be zero.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Xiaomingzzhang/InvariantManifolds.jl/blob/37da36cde53160039ab4c125941862d274694a3e/src/basic_constructors.jl#L89-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantManifolds.PiecewiseV" href="#InvariantManifolds.PiecewiseV"><code>InvariantManifolds.PiecewiseV</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PiecewiseV</code></pre><p>A callable struct to represent a piecewise smooth vector field. </p><p><strong>Fields</strong></p><ul><li><code>fs</code> is a tuple of smooth vector fields in different regions.</li><li><code>regions</code> is a tuple of the region functions: <code>(r1,r2,...)</code>, where <code>r1(x,p,t)</code> should return a Bool value to indicate that <code>x</code> is in this region or not.</li><li><code>hypers</code> is a tuple of the hyper surfaces separating the regions.</li><li><code>n</code> is a integer to switch between vector fields. Default to be zero.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using StaticArrays, InvariantManifolds
f1(x,p,t)=SA[x[2],-2x[1]]
f2(x,p,t)=SA[x[2],-x[1]]
dom1(x,p,t)=x[1]&gt;0
dom2(x,p,t)=x[2]&lt;0
hyper(x,p,t)=x[1]
PiecewiseV((f1,f2),(dom1,dom2),(hyper,))</code></pre><p>The above codes generate a piecewise smooth vector field, which when <code>x[1]&gt;0</code> is <code>f1</code>, and when <code>x[2]&lt;0</code> is <code>f2</code>. The hyper surface separating these smooth vector fields is <code>x[1]=0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Xiaomingzzhang/InvariantManifolds.jl/blob/37da36cde53160039ab4c125941862d274694a3e/src/basic_constructors.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantManifolds.Saddle" href="#InvariantManifolds.Saddle"><code>InvariantManifolds.Saddle</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Saddle{N,T,S}</code></pre><p><code>Saddle</code> is a struct to contain the information of a saddle point needed in continuing the manifold of non-smooth ODE. For an ODE&#39;s saddle, this struct can be constructed by the function <a href="#InvariantManifolds.findsaddle-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Any, StaticArraysCore.SVector{N, T}, Any}} where {N, T}"><code>findsaddle</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>saddle</code> the location of the saddle point;</li><li><code>unstable_directions</code> the unstable directions;</li><li><code>unstable_eigen_values</code> eigenvalues of the linearized map in the saddle at the unstable eigenvectors.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Xiaomingzzhang/InvariantManifolds.jl/blob/37da36cde53160039ab4c125941862d274694a3e/src/basic_constructors.jl#L189-L198">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantManifolds.TwoDManifold" href="#InvariantManifolds.TwoDManifold"><code>InvariantManifolds.TwoDManifold</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TwoDManifold{F,S,N,T}</code></pre><p><code>TwoDManifold</code> is a struct contains all the information of the two-dimensional numerical manifold of a nonlinear map.</p><p><strong>Fields</strong></p><ul><li><code>prob</code> the problem <a href="#InvariantManifolds.TwoDManifoldProblem"><code>TwoDManifoldProblem</code></a>;</li><li><code>data</code> the numerical data that should be <code>Vector{S}</code>, where <code>S</code> is the interpolation curve (we use <code>DataInterpolation</code> in this package);</li><li><code>flawpoints</code> the flaw points generated during continuation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Xiaomingzzhang/InvariantManifolds.jl/blob/37da36cde53160039ab4c125941862d274694a3e/src/smooth_maps_two.jl#L46-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantManifolds.TwoDManifoldProblem" href="#InvariantManifolds.TwoDManifoldProblem"><code>InvariantManifolds.TwoDManifoldProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TwoDManifoldProblem{F,T}</code></pre><p><code>TwoDManifoldProblem</code> is a struct to contain the main information for continuing the two-dimensional manifold of a nonlinear map.</p><p><strong>Fields</strong></p><ul><li><code>f</code> the nonlinear map, which should has the form <code>f(x,p)</code> and return a <code>SVector</code>;</li><li><code>para</code> the parameters of the nonlinear map;</li><li><code>amax</code> the maximum angle between points when continuing the manifold;</li><li><code>d</code> the maximum distance between points when continuing the manifold;</li><li><code>dcircle</code> the maximum distance between circles when continuing the manifold;</li><li><code>dsmin</code> the minimum arc length allowing; note that if in a continuation point, this value is achieved and the angle as well as the distance values are not achieved, then we will record this point as a <a href="#InvariantManifolds.FlawPoint"><code>FlawPoint</code></a>.</li></ul><p>Convenient consturctors are <code>TwoDManifoldProblem(f)</code> and <code>TwoDManifoldProblem(f,para)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Xiaomingzzhang/InvariantManifolds.jl/blob/37da36cde53160039ab4c125941862d274694a3e/src/smooth_maps_two.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantManifolds.VTwoDManifold" href="#InvariantManifolds.VTwoDManifold"><code>InvariantManifolds.VTwoDManifold</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">VTwoDManifold{F,S,N,T}</code></pre><p><code>VTwoDManifold</code> is a struct contains all the information of the two-dimensional numerical manifold of an autonomous vector field.</p><p><strong>Fields</strong></p><ul><li><code>prob</code> the problem <a href="#InvariantManifolds.VTwoDManifoldProblem"><code>VTwoDManifoldProblem</code></a>;</li><li><code>data</code> the numerical data that should be <code>Vector{S}</code>, where <code>S</code> is the interpolation curve (we use <code>DataInterpolation</code> in this package);</li><li><code>flawpoints</code> the flaw points generated during continuation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Xiaomingzzhang/InvariantManifolds.jl/blob/37da36cde53160039ab4c125941862d274694a3e/src/smooth_vectorfield_two.jl#L51-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantManifolds.VTwoDManifoldProblem" href="#InvariantManifolds.VTwoDManifoldProblem"><code>InvariantManifolds.VTwoDManifoldProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">VTwoDManifoldProblem{F,T}</code></pre><p><code>VTwoDManifoldProblem</code> is a struct to contain the main information for continuing the two-dimensional manifold of an autonomous vector field.</p><p><strong>Fields</strong></p><ul><li><code>f</code> the time flow map of the vector field, which should has the form <code>f(x,p)</code> and return a <code>SVector</code>; note that the vector field should be regularized, e.g., <span>$\dot{x}=v(x)$</span> should be rewritten as <span>$\dot{x}=v(x)/\sqrt{1+|v(x)|}$</span>;</li><li><code>para</code> the parameters of the time flow map;</li><li><code>amax</code> the maximum angle between points when continuing the manifold;</li><li><code>d</code> the maximum distance between points when continuing the manifold;</li><li><code>dsmin</code> the minimum arc length allowing; note that if in a continuation point, this value is achieved and the angle as well as the distance values are not achieved, then we will record this point as a <a href="#InvariantManifolds.FlawPoint"><code>FlawPoint</code></a>.</li></ul><p>Convenient consturctors are <code>VTwoDManifoldProblem(f)</code> and <code>VTwoDManifoldProblem(f,para)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Xiaomingzzhang/InvariantManifolds.jl/blob/37da36cde53160039ab4c125941862d274694a3e/src/smooth_vectorfield_two.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantManifolds.addcircles!-NTuple{8, Any}" href="#InvariantManifolds.addcircles!-NTuple{8, Any}"><code>InvariantManifolds.addcircles!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InvariantManifolds.addcircles!(f, para, d, circles, dsmin, αmax, dcircle, flawpoints; interp=LinearInterpolation)</code></pre><p>Adds and refines circles in the two-dimensional manifold computation by iterating the map and ensuring proper point distribution.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: The nonlinear map function</li><li><code>para</code>: Vector of parameters for the map</li><li><code>d</code>: Maximum allowed distance between points in a circle</li><li><code>circles</code>: Vector of interpolated curves representing the current circles</li><li><code>dsmin</code>: Minimum allowed arc length between points</li><li><code>αmax</code>: Maximum allowed angle between consecutive points</li><li><code>dcircle</code>: Maximum allowed distance between consecutive circles</li><li><code>flawpoints</code>: Vector to store problematic points during computation</li><li><code>interp</code>: Interpolation method (default: QuadraticInterpolation)</li></ul><p><strong>Returns</strong></p><p>A vector of new interpolated curves representing the refined circles after one iteration of the map.</p><p><strong>Details</strong></p><p>The function performs two main steps:</p><ol><li>Iterates each circle forward under the map and refines point distribution within each circle</li><li>Adds intermediate circles where the distance between consecutive circles exceeds <code>dcircle</code></li></ol><p>Points are added to maintain proper spacing and curvature constraints specified by <code>d</code> and <code>αmax</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Xiaomingzzhang/InvariantManifolds.jl/blob/37da36cde53160039ab4c125941862d274694a3e/src/smooth_maps_two.jl#L205-L230">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantManifolds.addpoints!-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Any, Any, Array{StaticArraysCore.SVector{N, T}, 1}, Vector{T}, Any, Any, Any}} where {N, T}" href="#InvariantManifolds.addpoints!-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Any, Any, Array{StaticArraysCore.SVector{N, T}, 1}, Vector{T}, Any, Any, Any}} where {N, T}"><code>InvariantManifolds.addpoints!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InvariantManifolds.addpoints!(f, p, d, oldcurve, newu, olds, dsmin, αmax, flawpoints)</code></pre><p>Add points to ensure proper spacing and curvature along a one-dimensional manifold curve.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: The nonlinear map function</li><li><code>p</code>: Parameters for the nonlinear map</li><li><code>d</code>: Maximum allowed distance between consecutive points</li><li><code>oldcurve</code>: Previous curve interpolation</li><li><code>newu::Vector{SVector{N,T}}</code>: New points to be processed</li><li><code>olds::Vector{T}</code>: Parameter values of the points</li><li><code>dsmin</code>: Minimum allowed arc length between points</li><li><code>αmax</code>: Maximum allowed angle between consecutive segments</li><li><code>flawpoints</code>: Vector to store problematic points that don&#39;t meet criteria</li></ul><p><strong>Details</strong></p><p>The function iteratively processes points, adding new ones when:</p><ul><li>The distance between consecutive points exceeds <code>d</code></li><li>The angle between consecutive segments exceeds <code>αmax</code></li><li>The arc length is greater than <code>dsmin</code></li></ul><p>If a point fails these criteria and the minimum arc length is reached, it&#39;s recorded as a flaw point.</p><p><strong>Returns</strong></p><p>Vector of parameter values for the new points</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Xiaomingzzhang/InvariantManifolds.jl/blob/37da36cde53160039ab4c125941862d274694a3e/src/smooth-one.jl#L159-L185">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantManifolds.findsaddle-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Any, StaticArraysCore.SVector{N, T}, Any}} where {N, T}" href="#InvariantManifolds.findsaddle-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Any, StaticArraysCore.SVector{N, T}, Any}} where {N, T}"><code>InvariantManifolds.findsaddle</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">findsaddle(v, dv, timespan, x, p)</code></pre><p><code>findsaddle</code> is a function to find the saddle of the time-T-map of smooth ODE systems, by using the Newton&#39;s method.</p><p><strong>Parameters</strong></p><ul><li><code>v</code> the vector field, which should be the form <code>f(x,p,t)</code> and return a <code>SVector</code>;</li><li><code>dv</code> the Jacobi matrix function of <code>v</code>, which should should be the form <code>dv(x,p,t)</code> and return a <code>SMatrix</code>;</li><li><code>timespan</code> the time span of the time-T-map;</li><li><code>x</code> the initial point to iterate.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>n</code> maximum iterate times, default to be 100;</li><li><code>abstol</code> absolute tolerance for the fixed point, default to be <code>1e-8</code>;</li><li><code>alg</code> the algorithm used to solve the ODE, default to be <code>Vern9()</code>.</li></ul><p>We also provide the finite difference method to find the saddle of the time-T-map of nonsmooth ODE systems:</p><p><strong>Parameters</strong></p><ul><li><code>setup</code> the <a href="#InvariantManifolds.NSSetUp"><code>NSSetUp</code></a> of the nonsmooth ODE system;</li><li><code>x</code> the initial point to iterate, of type <code>SVector{N,T}</code>.</li><li><code>p</code> the parameters of the nonsmooth ODE system.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>n</code> maximum iterate times, default to be 100;</li><li><code>abstol</code> absolute tolerance for the fixed point, default to be <code>1e-8</code>;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Xiaomingzzhang/InvariantManifolds.jl/blob/37da36cde53160039ab4c125941862d274694a3e/src/newton.jl#L33-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantManifolds.gen_disk-Union{Tuple{Saddle{N, T, S}}, Tuple{S}, Tuple{T}, Tuple{N}} where {N, T, S}" href="#InvariantManifolds.gen_disk-Union{Tuple{Saddle{N, T, S}}, Tuple{S}, Tuple{T}, Tuple{N}} where {N, T, S}"><code>InvariantManifolds.gen_disk</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gen_disk(p, times)</code></pre><p><code>gen_disk</code> is a function to generate circles around the saddle, which represented as the local manifold.</p><p><strong>Parameters</strong></p><ul><li><code>p</code> the struct <a href="#InvariantManifolds.Saddle"><code>Saddle</code></a> which should contains two unstable directions; the complex eigenvalues and eigenvectors are allowed.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>times</code> the iteration time, default to be <code>1</code>; for the computation of invariant manifolds of nonlinear map, this parameter is needed to adjust the torsion in different directions in the process of continuation.</li><li><code>n</code> the number of point in each circle, default to be <code>150</code>;</li><li><code>d</code> the max distance between points in a single circle, default to be <code>0.0002</code>;</li><li><code>r</code> the size of the disk, default to be <code>0.05</code>;</li><li><code>circles</code> the number of the circles, default to be <code>10</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Xiaomingzzhang/InvariantManifolds.jl/blob/37da36cde53160039ab4c125941862d274694a3e/src/smooth_maps_two.jl#L145-L157">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantManifolds.gen_segment-Union{Tuple{T}, Tuple{N}, Tuple{StaticArraysCore.SVector{N, T}, Any}} where {N, T}" href="#InvariantManifolds.gen_segment-Union{Tuple{T}, Tuple{N}, Tuple{StaticArraysCore.SVector{N, T}, Any}} where {N, T}"><code>InvariantManifolds.gen_segment</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gen_segment(saddle, direction)</code></pre><p>Generating <code>n</code> points at <code>saddle</code> in the <code>direction</code>, with length <code>d</code>, with default <code>n=50</code> and <code>d=0.01</code>. Another Convenient consturctor is <code>gen_segment(p::Saddle)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Xiaomingzzhang/InvariantManifolds.jl/blob/37da36cde53160039ab4c125941862d274694a3e/src/smooth-one.jl#L123-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantManifolds.grow!-Tuple{InvariantManifolds.OneDManifold}" href="#InvariantManifolds.grow!-Tuple{InvariantManifolds.OneDManifold}"><code>InvariantManifolds.grow!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grow!(manifold)</code></pre><p>One time iteration to grow the manifold.</p><p><strong>Parameters</strong></p><ul><li><code>manifold</code> the manifold struct.</li></ul><p><strong>Keyword argument</strong></p><ul><li><code>interp</code> the interpolation method used, default to be <code>QuadraticInterpolation</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Xiaomingzzhang/InvariantManifolds.jl/blob/37da36cde53160039ab4c125941862d274694a3e/src/smooth-one.jl#L256-L264">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantManifolds.growmanifold-Tuple{OneDManifoldProblem, Any, Any}" href="#InvariantManifolds.growmanifold-Tuple{OneDManifoldProblem, Any, Any}"><code>InvariantManifolds.growmanifold</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">growmanifold(prob, points, N)</code></pre><p>This is the mani function to continuate the numerical manifolds. Its output is a manifold struct.</p><p><strong>Parameters</strong></p><ul><li><code>prob</code> the problem such as <a href="#InvariantManifolds.OneDManifoldProblem"><code>OneDManifoldProblem</code></a>.</li><li><code>points</code> the points in the local manifold. For one dimensional manifolds, these points should be a <code>Vector{SVector}</code> and the start point should be the saddle. For two dimensional manifolds, these points should be a <code>Vector{Vector{S}}</code> and its first element should like <code>[saddle, saddle, saddle]</code>. Note that in the both cases, the functions <a href="#InvariantManifolds.gen_segment-Union{Tuple{T}, Tuple{N}, Tuple{StaticArraysCore.SVector{N, T}, Any}} where {N, T}"><code>gen_segment</code></a> and <a href="#InvariantManifolds.gen_disk-Union{Tuple{Saddle{N, T, S}}, Tuple{S}, Tuple{T}, Tuple{N}} where {N, T, S}"><code>gen_disk</code></a> can generate these points easily.</li><li><code>N</code> the number of iterations.</li></ul><p><strong>Keyword argument</strong></p><ul><li><code>interp</code> the interpolation method used, default to be <code>QuadraticInterpolation</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Xiaomingzzhang/InvariantManifolds.jl/blob/37da36cde53160039ab4c125941862d274694a3e/src/smooth-one.jl#L363-L374">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantManifolds.initialize-Union{Tuple{T}, Tuple{N}, Tuple{OneDManifoldProblem, Array{StaticArraysCore.SVector{N, T}, 1}}} where {N, T}" href="#InvariantManifolds.initialize-Union{Tuple{T}, Tuple{N}, Tuple{OneDManifoldProblem, Array{StaticArraysCore.SVector{N, T}, 1}}} where {N, T}"><code>InvariantManifolds.initialize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialize(prob, points)</code></pre><p>This is a function to initialize the continuation process. Its output is a manifold struct.</p><p><strong>Parameters</strong></p><ul><li><code>prob</code> the problem such as <a href="#InvariantManifolds.OneDManifoldProblem"><code>OneDManifoldProblem</code></a>.</li><li><code>points</code> the points in the local manifold. For one dimensional manifolds, these points should be a <code>Vector{SVector}</code> and the start point should be the saddle. For two dimensional manifolds, these points should be a <code>Vector{Vector{S}}</code> and its first element should like <code>[saddle, saddle, saddle]</code>. Note that in the both cases, the functions <a href="#InvariantManifolds.gen_segment-Union{Tuple{T}, Tuple{N}, Tuple{StaticArraysCore.SVector{N, T}, Any}} where {N, T}"><code>gen_segment</code></a> and <a href="#InvariantManifolds.gen_disk-Union{Tuple{Saddle{N, T, S}}, Tuple{S}, Tuple{T}, Tuple{N}} where {N, T, S}"><code>gen_disk</code></a> can generate these points easily.</li></ul><p><strong>Keyword argument</strong></p><ul><li><code>interp</code> the interpolation method used, default to be <code>QuadraticInterpolation</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Xiaomingzzhang/InvariantManifolds.jl/blob/37da36cde53160039ab4c125941862d274694a3e/src/smooth-one.jl#L320-L330">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantManifolds.iscontact-Union{Tuple{S}, Tuple{T}, Tuple{N}, Tuple{Any, Saddle{N, T, S}, Any}} where {N, T, S}" href="#InvariantManifolds.iscontact-Union{Tuple{S}, Tuple{T}, Tuple{N}, Tuple{Any, Saddle{N, T, S}, Any}} where {N, T, S}"><code>InvariantManifolds.iscontact</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">iscontact(setup, saddle, para)</code></pre><p>Check if the saddle point of the time-T-map has contacts with the hypersurfaces.</p><p><strong>Parameters</strong></p><ul><li><code>setup</code> a <a href="#InvariantManifolds.NSSetUp"><code>NSSetUp</code></a>.</li><li><code>saddle</code> a <a href="#InvariantManifolds.Saddle"><code>Saddle</code></a> or a <code>SVector</code>.</li><li><code>para</code> the parameter of the vector field.</li></ul><p><strong>Returns</strong></p><ul><li><code>true</code> if the saddle point has contact with the hypersurfaces.</li><li><code>false</code> if the saddle point has no contact with the hypersurfaces.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Xiaomingzzhang/InvariantManifolds.jl/blob/37da36cde53160039ab4c125941862d274694a3e/src/piecewise.jl#L133-L146">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantManifolds.kd_distence-Union{Tuple{T}, Tuple{N}, Tuple{StaticArraysCore.SVector{N, T}, Array{StaticArraysCore.SVector{N, T}, 1}}} where {N, T}" href="#InvariantManifolds.kd_distence-Union{Tuple{T}, Tuple{N}, Tuple{StaticArraysCore.SVector{N, T}, Array{StaticArraysCore.SVector{N, T}, 1}}} where {N, T}"><code>InvariantManifolds.kd_distence</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InvariantManifolds.kd_distence</code></pre><p>The function to measure the distance between two circles by using the package <code>NearestNeighbors.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Xiaomingzzhang/InvariantManifolds.jl/blob/37da36cde53160039ab4c125941862d274694a3e/src/smooth_maps_two.jl#L110-L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantManifolds.ns_addpoints!-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Any, Any, Any, Any, Array{NSState{N, T}, 1}, Vector{T}, Vararg{Any, 5}}} where {N, T}" href="#InvariantManifolds.ns_addpoints!-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Any, Any, Any, Any, Array{NSState{N, T}, 1}, Vector{T}, Vararg{Any, 5}}} where {N, T}"><code>InvariantManifolds.ns_addpoints!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InvariantManifolds.ns_addpoints!(tmap, p, d, dsmin, oldcurve, newu, olds, αmax, tend, hypers, ϵ, flawpoints) -&gt; Vector{T}</code></pre><p>Add points to ensure proper spacing and accuracy when computing the non-smooth one-dimensional manifold.</p><p><strong>Arguments</strong></p><ul><li><code>tmap</code>: Time map function that evolves states forward</li><li><code>p</code>: Vector of parameters</li><li><code>d</code>: Maximum allowed distance between consecutive points</li><li><code>dsmin</code>: Minimum allowed arc length between points</li><li><code>oldcurve</code>: Previous curve data used for interpolation</li><li><code>newu</code>: Vector of new states to be processed</li><li><code>olds</code>: Vector of arc length parameters</li><li><code>αmax</code>: Maximum allowed angle between consecutive segments</li><li><code>tend</code>: End time of the time map</li><li><code>hypers</code>: Vector of hypersurface functions</li><li><code>ϵ</code>: Maximum allowed error in hypersurface intersection</li><li><code>flawpoints</code>: Vector to store problematic points encountered</li></ul><p><strong>Returns</strong></p><ul><li>Vector of arc length parameters for the processed points</li></ul><p><strong>Details</strong></p><p>The function adaptively adds points to maintain:</p><ol><li>Maximum distance <code>d</code> between consecutive points</li><li>Maximum angle <code>αmax</code> between segments</li><li>Accuracy <code>ϵ</code> at hypersurface intersections</li></ol><p>If constraints cannot be satisfied within <code>dsmin</code>, points are marked as flaws.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Xiaomingzzhang/InvariantManifolds.jl/blob/37da36cde53160039ab4c125941862d274694a3e/src/nonsmooth-one.jl#L215-L244">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantManifolds.ns_solver-Tuple{PiecewiseV, Vararg{Any, 4}}" href="#InvariantManifolds.ns_solver-Tuple{PiecewiseV, Vararg{Any, 4}}"><code>InvariantManifolds.ns_solver</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ns_solver(v::T, para, timespan, alg, N, T)</code></pre><p>The function <code>ns_solver</code> is similar to <code>timetmap</code>. The output of this function is a function which maps a <code>SVector</code> to a <a href="#InvariantManifolds.NSSolution"><code>NSSolution</code></a>. This <code>NSSolution</code> contain all data of an non-smooth ODE solution.</p><p><strong>Parameters</strong></p><ul><li><code>v</code> vector fields like <a href="#InvariantManifolds.PiecewiseV"><code>PiecewiseV</code></a> or <a href="#InvariantManifolds.BilliardV"><code>BilliardV</code></a>.</li><li><code>para</code> the parameter of the vector field.</li><li><code>timespan</code> the time span of the time-T-map.</li><li><code>alg</code> algorithm in <code>OrdinaryDiffEq</code> to solve ODE.</li><li><code>N</code> the dimension of the vector field.</li><li><code>T</code> number type used in computation.</li></ul><p>To ensure type stable, the numbers in <code>para</code> and <code>timespan</code> should be type of <code>T</code>. The last two parameters have to be specified, since we need to store the event data.</p><p><strong>Keyword arguments</strong></p><ul><li><code>repeat_nudge=1//100</code> this is used to set the next testing point after a previously found zero.</li></ul><p>For vector fields <a href="#InvariantManifolds.PiecewiseV"><code>PiecewiseV</code></a> and <a href="#InvariantManifolds.PiecewiseImpactV"><code>PiecewiseImpactV</code></a>, we have two special keyword arguments:</p><ul><li><code>cross_time= 0.01</code> when the solution <code>sol</code> hits the hypersurface at time <code>t</code>, we need to know which domain it enters. We choose the state <code>sol(t+cross_time)</code> to determine which domain it enters.</li><li><code>region_detect=_region_detect</code> the region detect function to determine which domain the state in.</li></ul><p>You can also pass the keywords of <code>solve</code> of <a href="https://github.com/SciML/OrdinaryDiffEq.jl">OrdinaryDiffEq</a> to this function,  except the <code>callback</code> and saving related keywords.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Xiaomingzzhang/InvariantManifolds.jl/blob/37da36cde53160039ab4c125941862d274694a3e/src/piecewise.jl#L70-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantManifolds.setmap-Union{Tuple{T}, Tuple{PiecewiseV, Tuple{T, T}, Any}} where T" href="#InvariantManifolds.setmap-Union{Tuple{T}, Tuple{PiecewiseV, Tuple{T, T}, Any}} where T"><code>InvariantManifolds.setmap</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">setmap(v, timespan::Tuple{T,T}, alg) where {T}</code></pre><p>The function <code>setmap</code> is to get a <code>NSSetUp</code>.</p><p><strong>Parameters</strong></p><ul><li><code>v</code> a nonsmooth vector field like <a href="#InvariantManifolds.PiecewiseV"><code>PiecewiseV</code></a> or <a href="#InvariantManifolds.BilliardV"><code>BilliardV</code></a>.</li><li><code>timespan</code> the time span of the time-T-map.</li><li><code>alg</code> algorithm in <code>OrdinaryDiffEq</code> to solve ODE.</li></ul><p>To ensure type stable, the numbers in <code>timespan</code> should be type of <code>T</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>repeat_nudge=1//100</code> this is used to set the next testing point after a previously found zero.</li></ul><p>For vector fields <a href="#InvariantManifolds.PiecewiseV"><code>PiecewiseV</code></a> and <a href="#InvariantManifolds.PiecewiseImpactV"><code>PiecewiseImpactV</code></a>, we have two special keyword arguments:</p><ul><li><code>cross_time= 0.01</code> when the solution <code>sol</code> hits the hypersurface at time <code>t</code>, we need to know which domain it enters. We choose the state <code>sol(t+cross_time)</code> to determine which domain it enters.</li><li><code>region_detect=_region_detect</code> the region detect function to determine which domain the state in.</li></ul><p>You can also pass the keywords of <code>solve</code> of <a href="https://github.com/SciML/OrdinaryDiffEq.jl">OrdinaryDiffEq</a> to this function,  except the <code>callback</code> and saving related keywords.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Xiaomingzzhang/InvariantManifolds.jl/blob/37da36cde53160039ab4c125941862d274694a3e/src/piecewise.jl#L14-L36">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../non_smooth_two/">« Two-dimensional Non-Smooth Manifolds</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.2 on <span class="colophon-date" title="Thursday 1 May 2025 14:03">Thursday 1 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
